+++
date = "2025-07-25T09:52:00"
title = "线程池"
tags = ["JAVA","线程池","源码阅读"]
+++
[https://www.cnblogs.com/star95/p/17714057.html](https://www.cnblogs.com/star95/p/17714057.html)

# 一、定义
1、什么是线程池？

是一种管理和复用线程的机制，它通过预先创建一定数量的线程，将任务分配给这些线程执行，避免频繁的创建和销毁。

线程的核心组成包括：

线程集合、任务队列、拒绝策略。



2、用线程池的好处是什么？

降低资源消耗、提高响应速度、控制并发数量、统一管理线程、避免线程泄露。



3、常用的线程池有哪些？

+ ThreadPoolExecutor(基础实现类)
    - Java线程池的基础实现，所有线程池都是基于它实现的。
+ FixedThreadPool(固定大小线程池)
    - 固定大小的线程池，核心线程数量和最大线程数量一致。
    - 任务队列为LinkedBlockingQueue无界任务队列，使用时需要注意OOM。
+ CacheThreadPool(可缓存线程池)
+ ScheduleThreadPool(定时任务线程池)
+ SingleThreadPool(单线程线程池)
    - 核心线程数 == 最大线程数 = = 1 ，保证线程执行串行，适用顺序写入场景。
+ ForkJoinPool(分解任务线程池)
    - 支持分治算法的线程池，将大任务递归拆解成多个小任务，并行执行最后汇总结果。
    - 适用于排序搜索，递归求和。



4、使用线程池需要注意的地方？

避免通过ExecutorService创建的一些线程池的任务队列为无界任务队列，容易造成OOM，一般通过ThreadPoolExecutor指定参数自行创建。

例如FixedThreadPool：

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```



5、ThreadPoolExecutor中submit和execute的区别？

submit包含execute方法，execute只支持runable传入无返回值，submit支持callable传入，有一个Future类返回值，通过这个返回值可以获取执行的结果状态等。



6、线程池的状态有哪些，它们之间是怎么流转的？

running ：线程池创建之后的默认状态 

running = 调用shutdown() => shutdown状态：不再接收新任务,处理剩余任务

running = 调用shutdownNow() => stop状态: 不再接收任务，并不再处理任务，且尝试中断任务。

stop ==> tidying : 线程销毁完毕，任务队列为空。

tidying ==> terminated: 调用线程池关闭前的勾子方法，线程池关闭

![](https://cdn.nlark.com/yuque/0/2025/png/22648511/1749714942339-0c261415-12b2-43e2-b78a-14313ea8d5ae.png)



7、线程池的工作流程是怎样的？任务提交后会经历哪些步骤？

提交任务时，若当前线程数 < 核心线程数，创建新线程执行任务。

若当前线程数 ≥ 核心线程数，将任务放入队列。

若队列已满且线程数 < 最大线程数，创建非核心线程执行任务。

若队列已满且线程数 ≥ 最大线程数，触发拒绝策略。



8、如何合理配置线程池的核心线程数和最大线程数？

参考答案：

CPU 密集型任务：核心线程数 = CPU 核心数 + 1（避免 CPU 上下文切换）。

IO 密集型任务：核心线程数 = CPU 核心数 × 2（IO 操作不占用 CPU，可多分配线程）。

混合型任务：根据 IO 与 CPU 操作的比例调整，或拆分为两个线程池。

最大线程数：通常设为核心线程数的 1.5~2 倍，具体取决于任务特性和系统资源。



9、拒绝策略有哪些？

1、直接抛异常；

2、直接丢弃任务；

3、丢弃队列中最老的任务；

4、提交任务的线程执行任务。



10、shutDown和shutDownNow的区别？

shutdown：不再接收新任务,处理剩余任务

shutDownNow：不再接收任务也不处理任务，并尝试中断正在处理的任务，将未处理的任务当方法返回值返回。



11、submit() 和 execute() 方法的区别是什么？

返回值：

execute()：void，无法获取任务结果。

submit()：返回 Future 对象，可通过 get() 获取任务结果或取消任务。

异常处理：

execute()：任务抛出的异常直接传递给调用者（由线程池的 UncaughtExceptionHandler 处理）。

submit()：异常被封装在 Future 中，调用 get() 时才抛出 ExecutionException。

任务类型：

execute()：仅支持 Runnable（无返回值）。

submit()：支持 Runnable 和 Callable（有返回值）。

适用场景：

execute()：执行简单任务，无需结果。

submit()：执行异步计算，需获取结果或处理异常。



12、线程池中的Worker是什么，为什么在处理任务前Worker需要先unlock？

worker本质就是线程和任务的封装，没一个实例对应一个线程。负责从队列里面获取并执行任务。

worker获取任务时，如果队列为空会阻塞线程一段时间再返回，释放锁的原因是可以让线程池在这段时间如果发生了状态变更可以去中断线程的任务获取。



13、任务执行时为什么Worker需要加锁？

本质就是为了防止worker在执行任务的时候被线程池更改状态，在shutdownNow的时候线程池会尝试中断正在执行的任务，区分的边界就是上锁之前的Worker可以被中断。

# 二、源码
![](https://cdn.nlark.com/yuque/0/2025/png/22648511/1749632712335-d4ff88c1-1347-4717-b3d8-a9929c31ccf9.png)

## Executor
```java
public interface Executor {
    /**
	 * 核心且基础的任务执行方法
	 */
    void execute(Runnable command);
}
```



## ExecutorService
>  ExecutorService定义了一系列的线程池的操作
>

```java
package java.util.concurrent;
import java.util.List;
import java.util.Collection;

public interface ExecutorService extends Executor {

    //终止线程池，不再接收新任务，完成当前已有任务
    void shutdown();

    //立即终止线程池，队列中的任务不再执行，线程执行中的继续，返回当前未完成的任务
    List<Runnable> shutdownNow();

    //判断线程池是否终止，只要线程池不是Running都返回true
    boolean isShutdown();

    //判断线程池是否完全终止，状态是TERMINATED
    boolean isTerminated();

    //阻塞等待，直到线程池是TERMINATED状态，设置等待超时时间
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;

    //提交callAble任务返回Future
    <T> Future<T> submit(Callable<T> task);

   //提交runable任务，future就是入参result
    <T> Future<T> submit(Runnable task, T result);

    //提交runable任务，返回值为null
    Future<?> submit(Runnable task);

    //执行所有callable任务的集合
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
        throws InterruptedException;

    //执行所有callable任务的集合，带超时时间
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;

    //执行callable任务集合，返回第一个执行完的结果
    <T> T invokeAny(Collection<? extends Callable<T>> tasks)
        throws InterruptedException, ExecutionException;

    //执行callable任务集合，返回第一个执行完的结果，等待返回结果超时时间
    <T> T invokeAny(Collection<? extends Callable<T>> tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}

```



## AbstractExecutorService
<font style="color:rgb(51, 51, 51);">AbstractExecutorService是一个抽象类，实现了接口的一些方法，未实现的方法继续留给子类实现。</font>

```java
public abstract class AbstractExecutorService implements ExecutorService {
 
    /**
     * 将Runnable封装成RunnableFuture
     */
    protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
        return new FutureTask<T>(runnable, value);
    }
 
    /**
     * 将Callable封装成RunnableFuture
     */
    protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
        return new FutureTask<T>(callable);
    }
 
    /**
     * 提交Runnable任务，返回Future，真正执行任务的是子类实现的execute方法
     */
    public Future<?> submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<Void> ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }
 
    /**
     * 提交Runnable任务，返回Future，Future的get方法返回值是result参数的值
     */
    public <T> Future<T> submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }
 
    /**
     * 提交Callable任务，返回Future
     */
    public <T> Future<T> submit(Callable<T> task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }
	// 其他invoke相关方法默认实现使用场景较少，这里不再列出具体方法逻辑了，可自行阅读源码
    ...
 
}
```

## ThreadPoolExecutor
入口

> `<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">ThreadPoolExecutor</font>`<font style="color:rgb(31, 35, 40);"> </font><font style="color:rgb(31, 35, 40);">3 个最重要的参数：</font>
>
> + `<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">corePoolSize</font>`<font style="color:rgb(31, 35, 40);"> </font><font style="color:rgb(31, 35, 40);">: 任务队列未达到队列容量时，最大可以同时运行的线程数量。</font>
> + `<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">maximumPoolSize</font>`<font style="color:rgb(31, 35, 40);"> </font><font style="color:rgb(31, 35, 40);">: 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</font>
> + `<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">workQueue</font>`<font style="color:rgb(31, 35, 40);">: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</font>
>
> `<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">ThreadPoolExecutor</font>`<font style="color:rgb(31, 35, 40);">其他常见参数 :</font>
>
> + `<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">keepAliveTime</font>`<font style="color:rgb(31, 35, 40);">:线程池中的线程数量大于</font><font style="color:rgb(31, 35, 40);"> </font>`<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">corePoolSize</font>`<font style="color:rgb(31, 35, 40);"> </font><font style="color:rgb(31, 35, 40);">的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了</font><font style="color:rgb(31, 35, 40);"> </font>`<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">keepAliveTime</font>`<font style="color:rgb(31, 35, 40);">才会被回收销毁。</font>
> + `<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">unit</font>`<font style="color:rgb(31, 35, 40);"> </font><font style="color:rgb(31, 35, 40);">:</font><font style="color:rgb(31, 35, 40);"> </font>`<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">keepAliveTime</font>`<font style="color:rgb(31, 35, 40);"> </font><font style="color:rgb(31, 35, 40);">参数的时间单位。</font>
> + `<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">threadFactory</font>`<font style="color:rgb(31, 35, 40);"> </font><font style="color:rgb(31, 35, 40);">:executor 创建新线程的时候会用到。</font>
> + `<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">handler</font>`<font style="color:rgb(31, 35, 40);"> :拒绝策略，当核心线程正在执行，任务队列加满，最大线程也满了之后会根据选择的策略进行处理。</font>
>     - <font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">AbortPolicy: 会在submit的时候抛出RejectedExecutionException异常。</font>
>     - <font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">DiscardPolicy：不处理新任务直接丢弃。</font>
>     - <font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">DiscardOldestPolicy：此策略将丢弃最早未处理的任务请求。</font>
>     - <font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">CallerRunsPolicy：调用执行自己的线程运行，即主线程运行这个任务</font>
>

```java
package com.example.threadpool.threadpoolexecutor;

import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

public class ThreadPool {
    //定义线程工厂，用于线程池中创建线程 自定义线程名称方便问题定位
    static ThreadFactory threadFactory = new ThreadFactory() {
        private final AtomicInteger threadCount = new AtomicInteger(1);

        @Override
        public Thread newThread(Runnable r) {
            Thread thread = new Thread(r);
            thread.setDaemon(false);
            thread.setName("custom-thread--" + threadCount.getAndIncrement());
            return thread;
        }
    };
    static ThreadPoolExecutor executor = new ThreadPoolExecutor(3, //核心线程数
            5,//最大线程数
            60*10L, //空闲线程存活最大时间
            TimeUnit.SECONDS, //时间单位
            new LinkedBlockingQueue<>(100), //任务队列
            threadFactory, //线程工厂
            new ThreadPoolExecutor.AbortPolicy() //拒绝策略
    );
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        for (int i = 0; i < 100; i++) {
            final int taskIndex = i;
            if (i % 2 == 0) {
                Future<Integer> future = executor.submit(() -> {
                    try {
                        System.out.println("提交一个任务" + taskIndex);
                        //模拟线程任务执行时间
                        Thread.sleep(50);
                        return taskIndex;
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                });
                System.out.println(future.get());
            }else {
                executor.execute(() -> {
                    System.out.println("提交一个任务" + taskIndex);
                    //模拟线程任务执行时间
                    try {
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                });
            }
        }
        //调用了这个方法之后线程池不再加入新任务，当前所有任务执行完毕之后关闭线程池
        executor.shutdown();
        boolean awaitTermination = executor.awaitTermination(20, TimeUnit.SECONDS);
        if (awaitTermination) {
            System.out.println("所有任务执行完成，线程池已关闭");
        } else {
            System.out.println("等待超时，强制关闭线程池");
            //该方法会关闭线程池，并返回未执行完的任务。
            List<Runnable> runnables = executor.shutdownNow();
        }
    }
}

```

> 线程通过int来表示线程池的状态和线程数量，int型占4个字节32位，其中高3位表示线程状态，低29位表示线程数量，所以理论线程的最大数量是 2^29 - 1 = <font style="color:rgb(51, 51, 51);">536870911个。</font>
>
> 线程池状态
>
> + RUNNING
>     - 状态值：-1
>     - 描述：正常运行，并接受和处理任务，线程池创建之后的默认状态。
> + SHUTDOWN
>     - 状态值：0
>     - 描述：不再接受新任务，但会处理队列中已有的任务。
>     - 触发条件：调用shutDown方法
> + STOP
>     - 状态值：1
>     - 描述：不再接受新任务且不再处理任务队列中的任务，且尝试中断正在执行中的任务。
>     - 触发条件：调用shutDownNew方法
> + TIDYING
>     - 状态值：2
>     - 描述：所有任务已终止，工作线程数量为0，线程即将进入terminated状态。
>     - 触发条件：SHUTDOWN状态下队列和线程池都为空时或STOP状态下线程池为空。
> + TERMINATED
>     - 状态值：3
>     - 描述：线程池完全终止，勾子方法调用完毕
>     - 触发条件：<font style="color:rgb(0, 0, 0);background-color:rgba(0, 0, 0, 0.06);">TIDYING状态下 terminated()方法执行完毕</font>
>

```java
//当前工作线程数量
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
// 值是29，两个意思，一是表示最大线程数量占用的二进制位数，二是左移29位可以取得线程池状态。
private static final int COUNT_BITS = Integer.SIZE - 3;
// 线程池RUNNING状态，-1的二进制是：11111111 11111111 11111111 11111111，左移29位的结果，二进制表示为：11100000 00000000 00000000 00000000,高三位是111，表示的整数就是-536870912
private static final int RUNNING    = -1 << COUNT_BITS;
// 线程池SHUTDOWN状态，0的二进制是：00000000 00000000 00000000 00000000，左移29位的结果，二进制表示为：00000000 00000000 00000000 00000000,高三位是000，表示的整数就是0
private static final int SHUTDOWN   =  0 << COUNT_BITS;
// 线程池STOP状态，1的二进制是：00000000 00000000 00000000 00000001，左移29位的结果，二进制表示为：00100000 00000000 00000000 00000000,高三位是001，表示的整数就是536870912
private static final int STOP       =  1 << COUNT_BITS;
// 线程池TIDYING状态，2的二进制是：00000000 00000000 00000000 00000010，左移29位的结果，二进制表示为：01000000 00000000 00000000 00000000,高三位是010，表示的整数就是1073741824
private static final int TIDYING    =  2 << COUNT_BITS;
// 线程池TERMINATED状态，3的二进制是：00000000 00000000 00000000 00000011，左移29位的结果，二进制表示为：01100000 00000000 00000000 00000000,高三位是011，表示的整数就是1610612736
private static final int TERMINATED =  3 << COUNT_BITS;

private static final int COUNT_BITS = Integer.SIZE - 3;
// CAPACITY表示线程池中线程的容量
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;
// 获取线程池状态，~CAPACITY取反的结果就是高3位是1，低29位是0，然后跟c与操作，最终就是c的高3位+29位0的二进制转换成int就是线程池的状态
private static int runStateOf(int c)     { return c & ~CAPACITY; }
// 获取线程数量，CAPACITY高3位是0低29位是1，然后跟c与操作，最终就是高3位是0+c的低29位结果的二进制转换成int就是线程数量
private static int workerCountOf(int c)  { return c & CAPACITY; }
// 将线程池状态rs、线程数量wc执行或操作，ctlOf方法返回的int值就包含了这两个属性，用一个整数表示了。
private static int ctlOf(int rs, int wc) { return rs | wc; }
// 判断线程池状态是否小于s
private static boolean runStateLessThan(int c, int s) {
    return c < s;
}
// 判断线程池状态至少大于s
private static boolean runStateAtLeast(int c, int s) {
    return c >= s;
}
// 判断线程池是否在运行中
private static boolean isRunning(int c) {
    return c < SHUTDOWN;
}
 
// cas操作，将线程数加1
private boolean compareAndIncrementWorkerCount(int expect) {
    return ctl.compareAndSet(expect, expect + 1);
}
 
// cas操作，将线程数减1
private boolean compareAndDecrementWorkerCount(int expect) {
    return ctl.compareAndSet(expect, expect - 1);
}
 
// 将线程数减1，自旋操作，直到减1成功
private void decrementWorkerCount() {
    do {} while (! compareAndDecrementWorkerCount(ctl.get()));
}
```

其他相关变量

```java
//存放任务的阻塞队列
private final BlockingQueue<Runnable> workQueue;
//线程池相关操作的锁，全局锁，线程创建和线程池关闭等操作都要上锁。
private final ReentrantLock mainLock = new ReentrantLock();
//存放线程
private final HashSet<Worker> workers = new HashSet<Worker>();
//锁的变量条件，线程终止的时候会用到
private final Condition termination = mainLock.newCondition();
//线程池达到过的最大线程数
private int largestPoolSize;
//线程池总计完成任务个数
private long completedTaskCount;
//创建线程的线程工厂，可自行定位
private volatile ThreadFactory threadFactory;
// 拒绝策略，可自定义
private volatile RejectedExecutionHandler handler;
// 非核心线程最大空闲时间，（如果允许核心线程退出，也使用这个空闲时间）
private volatile long keepAliveTime;
// 是否允许核心线程超时销毁，默认false，可设置为true，最低也需要有一个核心线程
private volatile boolean allowCoreThreadTimeOut;
// 核心线程数
private volatile int corePoolSize;
// 最大线程数
private volatile int maximumPoolSize;
// 拒绝策略
private static final RejectedExecutionHandler defaultHandler =
    new AbortPolicy();
```



### submit
>  提交一个任务，主要看里面的execute方法
>
> + 获取工作线程数量，判断是否大于等于核心线程数
>     - 大于：判断当前线程池是否是RUNNING状态 && 将任务添加到阻塞队列
>         * 是：二次确认当前线程池状态是否为RUNNING
>             + 是：调用addWork创建一个线程
>             + 否：将当前任务移除阻塞队列，并调用拒绝策略
>         * 否：尝试以最大线程数量创建线程，创建失败则调用拒绝策略
>     - 小于：创建一个线程，并将当前任务作为线程的第一个任务
>         * 创建失败调用大于的方法
>

```java
public <T> Future<T> submit(Callable<T> task) {
    if (task == null) throw new NullPointerException();
    RunnableFuture<T> ftask = newTaskFor(task);
    execute(ftask);
    return ftask;
}

public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn't, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         */
        //获取工作线程数量
        int c = ctl.get();
        //如果工作线程小于核心线程
        if (workerCountOf(c) < corePoolSize) {
            //创建一个核心线程，将当前任务作为首个任务赋予核心线程
            if (addWorker(command, true))
                return;//添加核心线程成功直接返回
            c = ctl.get();
        }
        //走到这里：1、上一步创建核心线程失败 or 2、当前工作线程大于等于核心线程数量
        //线程池还在运行 && 将任务添加到阻塞队列
        if (isRunning(c) && workQueue.offer(command)) {
            //再次检查标记
            int recheck = ctl.get();
            //如果线程池不在运行状态，则将任务对阻塞队列中移除
            //这个时候可能调用了shutdown方法
            if (! isRunning(recheck) && remove(command))
                //进行拒绝策略
                reject(command);
                //线程池是RUNNING状态，且当前工作线程为0
            else if (workerCountOf(recheck) == 0)
                //增加一个工作线程
                addWorker(null, false);
        }//如果线程池不在运行或者添加任务到阻塞队列失败
            //尝试以最大线程数量为限制创建线程
        else if (!addWorker(command, false))
            //创建失败进行拒绝策略
            reject(command);
    }
```

#### addWork
> 添加线程
>
> + 第一阶段
>     - 通过CAS将ctl的工作线程数量+1，主要是判断线程数量是否达到限制和线程池的状态。
> + 第二阶段
>     - 通过mianLock全局锁创建线程，并将线程添加到线程池中，这一步也需要判断线程池的状态
> + 兜底
>     - 如果线程创建失败，会将ctl的工作线程数量-1，并移除对应的工作线程。
>

```java
private boolean addWorker(Runnable firstTask, boolean core) {
    retry://循环跳出标识符
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
 
        // 判断是否需要添加线程 
        if (rs >= SHUTDOWN && !(rs == SHUTDOWN && firstTask == null && !workQueue.isEmpty())) {
            return false;
        }
        //CAS去增加线程数量
        for (;;) {
            int wc = workerCountOf(c);
            //如果当前工作线程大于可创建的最大线程数返回false
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            //cas线程计数+1
            if (compareAndIncrementWorkerCount(c))
                break retry;//跳出到最外层循环开始正式线程创建
            c = ctl.get();  // Re-read ctl
            //二次校验，工作线程数量变更
            if (runStateOf(c) != rs)
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }

    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        //构造一个Worker对象，构造方法就是创建一个线程
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            //获取全局锁
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                //获取线程池的状态
                int rs = runStateOf(ctl.get());

                //线程池是RUNNING或者 在SHUTDOWN时任务为空
                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    //将创建的线程放入线程池中
                    workers.add(w);
                    int s = workers.size();
                    //用于标记当前线程池中的最大线程数。非最大限制线程数量
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            // 如果成功添加了 Worker，就可以启动 Worker 了
            if (workerAdded) {
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            //添加失败，需要将上一步CAS增加的线程数量回滚
            addWorkerFailed(w);
    }
    return workerStarted;
}

private void addWorkerFailed(Worker w) {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        if (w != null)
            //移除线程
            workers.remove(w);
        //线程数量-1
        decrementWorkerCount();
        //判断是否需要终止线程池
        tryTerminate();
    } finally {
        mainLock.unlock();
    }
}
```

### Worker
> work是ThreadPoolExecutor内部类，就是具体的工作线程，通过AQS同步机制控制对工作线程的访问。
>
> 继承自AbstractQueuedSynchronizer
>
> Worker中锁的粒度是Worker级别的，作用不是保证任务执行的串行化，而是保证当前Worker在执行任务的时候其状态不被线程池操作任意更改。
>
> + worker实现Runnable接口中的run方法，内置调用ThreadPoolExecutor中的runWorker方法
> + 再获取任务时，先释放锁，防止阻塞队列为空一直等待资源占用
>     - 获取任务：根据线程池判断是否需要获取任务，且根据当前线程数量决定获取任务的策略
>         * 当前线程数量大于核心线程数量：采用超时poll的方式获取，超过时限未获取到则返回null。
>         * 当前线程数量小于核心线程数量：采用take方式获取，线程挂起，直到队列中有任务再唤醒。
>     - 未获取到任务，线程数量大于核心线程数量，则销毁当前线程。
> + 获取到任务之后，对Worker上锁，防止执行任务时被线程池更改Worker的状态。
> + 调用任务执行的前置方法
> + 执行任务
> + 调用任务执行的后置方法。
> + 更新任务正常处理标识符，更新任务处理数量
> + 根据任务正常处理标识符判断当前线程是否正常处理任务退出
>     - 非正常退出：销毁当前线程
>     - 正常退出：
>         * 根据线程池状态判断是否销毁
>         * 根据工作线程数量 + 任务队列是否有任务判断是否销毁线程
>

```java
private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
    {
        private static final long serialVersionUID = 6138294804551838833L;
        //当前工作线程
        final Thread thread;
        //当前执行的任务
        Runnable firstTask;
        //当前工作线程执行的任务数量
        volatile long completedTasks;

        //构造方法创建线程并赋予任务
        Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }

        public void run() {
            //调用外部的ThreadPoolExecutor runWorker方法
            runWorker(this);
        }
    }
```

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // 提前释放锁，getTask()获取阻塞队列中任务时，如果没有任务会一直阻塞，需要提前释放
    //标记任务退出状态：false 线程执行完退出 true 线程执行异常退出
    boolean completedAbruptly = true;
    try {
        //循环获取任务
        while (task != null || (task = getTask()) != null) {
            //上锁
            w.lock();
            //判断线程状态是否需要终止
            if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP))) && !wt.isInterrupted()) {
                wt.interrupt();
            }
            try {
                //任务执行前置操作，默认为空
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    //任务执行
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    //任务执行后置操作，默认为空
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                //处理任务计数+1
                w.completedTasks++;
                //解锁
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}

//获取可执行任务
private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?
    //循环获取
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // 根据线程池状态判断是否需要获取任务
        //未获取到任务的线程会被销毁
        //线程池状态 >= SHUTDOWN的会被销毁
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            //线程数量 -1
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        // 标识符，如果工作线程大于核心线程数 从队列获取任务可以先通过poll的方式获取
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

        //根据参数判断 是否需要销毁线程。 任务队列为空 工作线程大于核心线程时销毁线程
        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            //线程数量 - 1
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            // 根据标识符 选择获取任务的方式
            //pull 无超时： 如果队列为空直接返回null
            //pull 有超时：如果队列为空若在指定时间内还为空则返回null
            //take 线程会被挂起，队列有元素添加才会被唤醒获取任务
            Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
//判断是否需要销毁线程
private void processWorkerExit(Worker w, boolean completedAbruptly) {
    //非正常退出 线程数量-1 标记销毁当前线程
    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted
        decrementWorkerCount();

    //获取全局锁
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        //更新线程池总完成任务
        completedTaskCount += w.completedTasks;
        //移除当前Worker
        workers.remove(w);
    } finally {
        mainLock.unlock();
    }

    //销毁空闲线程
    tryTerminate();

    int c = ctl.get();
    //当前线程池还在运行
    if (runStateLessThan(c, STOP)) {
        //线程正常退出
        if (!completedAbruptly) {
            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
            if (min == 0 && ! workQueue.isEmpty())
                min = 1;
            //当前线程数大于计算出来的最小线程数则退出否则再创建一个线程
            if (workerCountOf(c) >= min)
                return; // replacement not needed
        }
        addWorker(null, false);
    }
}
//线程销毁或者线程池关闭时调用，主要判断是否需要销毁空闲线程
final void tryTerminate() {
    for (;;) {
        int c = ctl.get();
        //满足以下其一
        //如果当前线程池还在运行
        //线程池状态小于TIDYING时
        //线程池状态为阻塞且任务队列不为空时
        if (isRunning(c) ||
            runStateAtLeast(c, TIDYING) ||
            (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))
            return;
        //线程数量 > 0 则中断一个线程
        if (workerCountOf(c) != 0) { // Eligible to terminate
            interruptIdleWorkers(ONLY_ONE);
            return;
        }

        //走到这里了说明工作线程数量为0
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            //cas将线程池状态设置为TIDYING过渡状态
            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                try {
                    //调用这个扩展方法，一般为线程池关闭前的勾子方法
                    terminated();
                } finally {
                    //CAS将线程池设置为TERMINATED状态，标识线程池关闭
                    ctl.set(ctlOf(TERMINATED, 0));
                    termination.signalAll();
                }
                return;
            }
        } finally {
            mainLock.unlock();
        }
        // else retry on failed CAS
    }
}

```



### ShutDown
<font style="color:rgb(51, 51, 51);">将线程池状态设置为SHUTDOWN后不再接受新任务，将阻塞队列的任务执行完成后，线程池关闭。</font>

```java
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        // 设置线程池状态为SHUTDOWN
        advanceRunState(SHUTDOWN);
        // 给worker线程发中断标识
        interruptIdleWorkers();
        onShutdown(); // hook for ScheduledThreadPoolExecutor
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
}
 
private void advanceRunState(int targetState) {
    for (;;) {
        int c = ctl.get();
        // cas操作设置线程池状态为targetState
        if (runStateAtLeast(c, targetState) ||
            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))
            break;
    }
}
 
private void interruptIdleWorkers() {
    interruptIdleWorkers(false);
}
 
private void interruptIdleWorkers(boolean onlyOne) {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (Worker w : workers) {
            Thread t = w.thread;
            if (!t.isInterrupted() && w.tryLock()) {
                try {
                    // 中断工作线程，其实工作线程仍会继续走一遍循环，主要判断线程池状态和阻塞队列任务数来决定是否销毁
                    t.interrupt();
                } catch (SecurityException ignore) {
                } finally {
                    w.unlock();
                }
            }
            if (onlyOne)
                break;
        }
    } finally {
        mainLock.unlock();
    }
}
```

### ShutDownNow
<font style="color:rgb(51, 51, 51);">调用shutdownNow方法会将线程池状态设置为STOP后不再接受新任务，然后将所有线程中断（这里的中断已经拿到任务并执行不会响应中断，是在调用getTask获取下一个任务时看线程池状态为STOP则不会再取阻塞队列任务，直接返回null，然后工作线程销毁，还有一种情况是正在阻塞等待拿任务，阻塞在poll或take上，都会响应中断，然后再一次循环任务返回null），并将未执行的任务返回，线程池关闭。</font>

```java
public List<Runnable> shutdownNow() {
    List<Runnable> tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        // 设置线程池状态为STOP
        advanceRunState(STOP);
        // 中断所有线程
        interruptWorkers();
        // 将阻塞队列的剩余任务导出到新集合中并返回
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    return tasks;
}
 
private void interruptWorkers() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (Worker w : workers)
            w.interruptIfStarted();
    } finally {
        mainLock.unlock();
    }
}
 
// Worker类方法
void interruptIfStarted() {
    Thread t;
    if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
        try {
            // 中断工作线程，其实工作线程仍会继续走一遍循环，主要判断线程池状态和阻塞队列任务数来决定是否销毁
            t.interrupt();
        } catch (SecurityException ignore) {
        }
    }
}
```

<font style="color:rgb(51, 51, 51);">一般情况下，要关闭线程池建议使用shutdown，它会将阻塞队列的任务执行完成后再关闭线程池，比较稳妥，不会出现任务没有执行完的情况，如果要使用shutdownNow关闭线程池，则它会返回未执行的任务，需要根据业务情况做相应任务的处理。</font>

## 线程池扩展功能
> 1、任务执行前后处理，通过扩展ThreadPoolExecutor类，重写其beforExecute和afterExecute方法。
>
> beforExecute：任务执行前调用，通常用于资源申请、日志记录等；
>
> afterExecute：任务执行后调用，通常用于资源释放，结果清理等。
>
> 2、线程池关闭前的勾子函数
>
> terminated:通过这个函数在线程池关闭前进行日志记录或者资源回收
>

```java
package com.example.threadpool.threadpoolexecutor;

import org.apache.tomcat.util.threads.ThreadPoolExecutor;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;

public class ExtThreadPool extends ThreadPoolExecutor {
    public ExtThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory,handler);
    }

    @Override
    protected void beforeExecute(Thread t, Runnable r) {
        super.beforeExecute(t, r);
        System.out.println("beforeExecute" + "资源分配中");
    }

    @Override
    protected void afterExecute(Runnable r, Throwable t) {
        super.afterExecute(r, t);
        System.out.println("afterExecute" + "资源回收中");
    }

    @Override
    protected void terminated() {
        super.terminated();
        System.out.println("terminated" + "线程池关闭记录");
    }
}




static ExtThreadPool executor = new ExtThreadPool(3, //核心线程数
            5,//最大线程数
            60*10L, //空闲线程存活最大时间
            TimeUnit.SECONDS, //时间单位
            new LinkedBlockingQueue<>(100), //任务队列
            threadFactory, //线程工厂
            new MyRejectHandler() //拒绝策略
    );
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        for (int i = 0; i < 100; i++) {
            final int taskIndex = i;
            if (i % 2 == 0) {
                Future<Integer> future = executor.submit(() -> {
                    try {
                        System.out.println("提交一个任务" + taskIndex);
                        //模拟线程任务执行时间
                        Thread.sleep(50);
                        return taskIndex;
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                });
                System.out.println(future.get());
            }else {
                executor.execute(() -> {
                    System.out.println("提交一个任务" + taskIndex);
                    //模拟线程任务执行时间
                    try {
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                });
            }
        }
        //调用了这个方法之后线程池不再加入新任务，当前所有任务执行完毕之后关闭线程池
        executor.shutdown();
        boolean awaitTermination = executor.awaitTermination(20, TimeUnit.SECONDS);
        if (awaitTermination) {
            System.out.println("所有任务执行完成，线程池已关闭");
        } else {
            System.out.println("等待超时，强制关闭线程池");
            List<Runnable> runnables = executor.shutdownNow();
        }
    }
}
```

## 自定义拒绝策略
> 通过实现RejectExecutionHandler接口里面的rejectedExecution方法来实现自定义拒绝策略；
>
> 常见的拒绝策略有：
>
> 1、任务重试：将任务放入延迟队列进行延迟投递；
>
> 2、任务降级：根据任务类型对应的优先级采用不同的处理策略；
>
> 3、指标监控：记录拒绝数量，计算出拒绝率，触发告警动态调整线程池的参数；
>
> 4、任务序列化：被拒绝的策略进行序列化或者投递到MQ中等后续进行处理；
>
> 5、负载均衡处理：根据系统的负载均衡进行任务路由。
>

```java
package com.example.threadpool.threadpoolexecutor;

import org.apache.tomcat.util.threads.ThreadPoolExecutor;

public class MyRejectHandler implements ThreadPoolExecutor.RejectedExecutionHandler {
    @Override
    public void rejectedExecution(Runnable runnable, ThreadPoolExecutor threadPoolExecutor) {
        Thread thread = new Thread(runnable);
        System.out.println("队列已满，拒绝入队" + thread.getName());
    }
}
```

