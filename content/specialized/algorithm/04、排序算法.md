+++
date = "2025-09-09T16:30:54"
title = "排序算法"
tags = ["算法"]
+++
# 一、定义
+ 选择排序
+ 冒泡排序
+ 插入排序
+ 归并排序
    - 是一种基于分治思想的排序，它将待排序数组分成若干个子数组，然后递归的对这些子数组进行排序，最后将子数组合并起来，成为一个有序的数组。
    - 归并排序技巧：
        * 分割：将数组不断分割，直到数组只包含一个元素，达到最小粒度
        * 排序：对每个子数组合并排序，通过比较两个子数组的元素大小来确定数组的顺序。
        * 合并：将以排序好的数组进行合并，成为一个大数组。
    - 适用于
        * 当数据规模较大，需要进行稳定排序时（及相等的数字顺序不变）。
        * 当对链表进行排序时，归并排序只需要修改指针指向，不需要进行元素移动，相对其他排序归并排序更合适。
+ 快速排序
    - 快速排序也是基于分治思想的排序，其中心思想是选择一个基准值，将数组分割成两部分，使得其中一部分小于基准值，另一部分大于基准值，然后对这两部分分别进行递归排序，最终实现整个数组的排序。
    - 快速排序技巧
        * 选择基准值：没有特别的要求，一般选择第一个、最后一个或者随机一个。
        * 分区：将小于基准值的放基准值左边，大于基准值的放基准值右边，使用双指针或者挖坑填数法。
        * 递归排序：对基准数左右两侧的子数组进行递归排序；即重复选择基准和分区操作，直到子数组大小为0或1时停止排序。
        * 合并结果：当递归调用完之后数组所有数值都是有序的。
    - 快排和递归之间的比较
        * 基本原理
            + 都是用了分治的思想，将数组分成多个小的部分，通过递归使得小数组有序，从而合并到大数组有序。
        * 分区方式
            + 快排基于基准值分成左右两个区间。
            + 归并将数组一分为二，然后对两个数组进行排序
        * 稳定性
            + 快排相对递归来说不太稳定，相同的元素在分区的过程中会变动位置。
        * <font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">时间复杂度</font>
            + <font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">快排最坏的情况时间复杂度会到达O(n^2),正常情况和递归一样都是n log n。</font>
        * 空间复杂度
            + <font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">快排是原地算法，不需要额外的空间进行排序，递归需要n大小的额外临时数组进行排序。</font>
+ 堆排序
+ 技术排序
+ 基数排序



# 二、示例
> 选择排序
>

> 冒泡排序
>

> 插入排序
>
> 维护一个下标i，i到0这段数组的顺序是有序的。比较交换i之后的数字，知道i为nums.length。
>
> 循环不变量，0 - i部分数据有序。
>

### 归并排序
> 归并排序
>
> 时间复杂度是O(nlog n),n是待排序的数组长度。空间复杂度O(n) ，merge中的临时数组空间
>
> 归并排序和其他排序的区别在于保留了每次比较排序的结果，杜绝了其他排序每次比较的独立性。
>
> 主要减少的比较的次数。
>
> Master公式: T(n) = 2 * T(n/2) + f(n);  == > O(nlog n)
>

```java
public static void sort(int[] nums,int left,int right){
        //排序
        if (left == right){
            return;
        }
        int mid = left + ((right - left) >> 1);
        //区间分割的右部分
        sort(nums,mid,right);
        //区间分割的左部分
        sort(nums,left,mid);
        //合并区间保证局部有序
        sortMerge(nums,left,mid,right);
    }

    public static void sortMerge(int[] nums,int left,int mid,int right){
        //临时数组进行排序
         int[][] temp = new int[right - left + 1];
         int k = 0;
         int i = left;
         int j = mid + 1;
         while (i <= mid && j <= right){
             //比较 插入
             int leftValue = nums[i];
             int rightValue = nums[j];
             if (leftValue < rightValue){
                 temp[k] = nums[i];
                 i++;
             }else {
                 temp[k] = nums[j];
                 j++;
             }
             k++;
         }
         while (j <= right){
             temp[k++] = nums[j++];
             //j++;
             //k++;
         }
         while (i <= mid){
             temp[k++] = nums[i++];
             //i++;
             //k++;
         }
         //将临时数组替换原数组中元素
        for (int i1 = 0; i1 < temp.length; i1++) {
            nums[i1 + left] = temp[i1];
        }
    }
```

```java
//在一个数组中，每一个数左边比当前小的数累加起来，叫做这个数组的小和。求一个数组的小和
//递归排序，并在排序的过程中确认左侧区间的数字需要进行多少次累加  只能选择左侧比当前数字小的数累加，如果小数出现在右侧则忽略
public static int sort(int[] nums,int left,int right){
        if (left == right){
            return 0;
        }
        int mid = left + ((right - left) >> 1);
        return sort(nums,left,mid) + sort(nums,mid + 1,right) + process(nums,left,right,mid);
    }

public static int process(int[] nums,int left,int right,int mid){
    //从最小区间开始 如果左侧值比右侧值小，说明左侧的值需要在总的最小和中出现一次
    //当区间变大时，左侧i的值小于右侧j的值，说明右侧有right - j个值比i的值大，所以左侧i出现 right - i次
    //至于i相对左侧其他大于它的数来说不做计算，因为上一步递归已经进行计算了
    int[] temp = new int[right - left + 1];
    int l = left;
    int r = mid + 1;
    int index = 0;
    int sum = 0;
    while (l <= mid && r <= right){
        if (nums[l] < nums[r]){
            sum += nums[l] * (right - r + 1);
            temp[index++] = nums[l++];
        }else {

            temp[index++] = nums[r++];
        }
    }
    while (l <= mid){
        temp[index++] = nums[l++];
    }
    while (r <= right){
        temp[index++] = nums[r++];
    }
    for (int i = 0; i < temp.length; i++) {
        nums[left + i] = temp[i];
    }
    return sum;
}
```



> 快速排序
>

```java

```



