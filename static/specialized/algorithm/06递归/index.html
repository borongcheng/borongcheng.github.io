<!doctype html>
<html lang="zh-CN">
  <head>
    <title>递归 // 笔记网站</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.121.0">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="borong.cheng" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/static/css/main.min.b84e0970f1042270e748e500e667d336cc11fd43e14b8fd28a91b688e487575c.css" />
    

    
    <meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://borongcheng.github.io/static/%E9%A6%96%E9%A1%B5%E4%B8%AD%E9%97%B4%E7%9A%84%E5%9B%BE%E7%89%87" /><meta name="twitter:title" content="递归"/>
<meta name="twitter:description" content="一、定义 递归是一种通过调用自身来解决问题的编程技巧或算法。 在递归的过程中将问题分解为规模较小的子问题，并通过调用自身来解决这些子问题，最终将"/>

    <meta property="og:title" content="递归" />
<meta property="og:description" content="一、定义 递归是一种通过调用自身来解决问题的编程技巧或算法。 在递归的过程中将问题分解为规模较小的子问题，并通过调用自身来解决这些子问题，最终将" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://borongcheng.github.io/static/specialized/algorithm/06%E9%80%92%E5%BD%92/" /><meta property="og:image" content="https://borongcheng.github.io/static/%E9%A6%96%E9%A1%B5%E4%B8%AD%E9%97%B4%E7%9A%84%E5%9B%BE%E7%89%87" /><meta property="article:section" content="specialized" />
<meta property="article:published_time" content="2025-09-11T14:00:54+00:00" />
<meta property="article:modified_time" content="2025-09-11T14:00:54+00:00" /><meta property="og:site_name" content="柏荣的博客" />



  </head>
  <body>
    <header class="app-header">
      <a href="https://borongcheng.github.io/static/"><img class="app-header-avatar" src="/static/picture/daji.jpg" alt="borong.cheng" /></a>
      <span class="app-header-title">笔记网站</span>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/static/">Home</a>
             - 
          
          <a class="app-header-menu-item" href="/static/categories/">类别</a>
             - 
          
          <a class="app-header-menu-item" href="/static/tags/">Tags</a>
      </nav>
      <p>柏荣的博客</p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">递归</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Sep 11, 2025
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          9 min read
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://borongcheng.github.io/static/tags/%E7%AE%97%E6%B3%95/">算法</a>
        </div>
      </div>
    </header>
    <div class="post-container">
      <div class="post-toc-container">
        
<div class="post-toc">
  <div class="post-toc-title">目录</div>
  <div class="post-toc-content">
    
    <nav>
  <ul>
    <li><a href="#回溯">回溯</a>
      <ul>
        <li><a href="#定义">定义</a></li>
        <li><a href="#解决的问题">解决的问题</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#通用模板">通用模板</a></li>
    <li><a href="#1全排列问题">1、全排列问题</a></li>
    <li><a href="#2子集合问题">2、子集合问题</a></li>
    <li><a href="#3n皇后问题">3、n皇后问题</a></li>
  </ul>

  <ul>
    <li><a href="#1普通递归">1、普通递归</a></li>
    <li><a href="#2递归回溯剪枝">2、递归回溯剪枝</a></li>
  </ul>
</nav>
  </div>
</div>

      </div>
      <div class="post-content">
        <h1 id="一定义">一、定义</h1>
<blockquote>
<p>递归是一种通过调用自身来解决问题的编程技巧或算法。</p>
<p>在递归的过程中将问题分解为规模较小的子问题，并通过调用自身来解决这些子问题，最终将所有子问题的结果合并以解决原始问题。</p>
</blockquote>
<ul>
<li>Master公式
<ul>
<li>是一种解决递归算法时间复杂度的公式，用于快速定位递归算法的时间复杂度，尤其适用分治算法中的递归问题。</li>
<li>一系列符合子问题等规模问题才可以通过Master公式来求时间复杂度</li>
<li>T(N)	=  a * T(n/b) + f(n)
<ul>
<li>T(N) 表示母问题时间复杂度</li>
<li>a 表示调用递归方法的次数</li>
<li>n/b  表示问题缩小比例</li>
<li>T(n/b) 表示递归子问题的时间复杂度</li>
<li>f(n)表示除递归之外的时间复杂度</li>
<li><!-- raw HTML omitted -->Master公式一般用于分析分治算法、递归算法、递归关系式等场景，特别是在算法设计和分析中有递归结构的问题中，可以帮助我们快速了解算法的时间复杂度。<!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted -->Master公式通常与递归树（Recurrence Tree）一起使用，递归树可以将递归算法的执行过程可视化，进而辅助使用Master公式求解递归算法的时间复杂度。<!-- raw HTML omitted --></li>
</ul>
</li>
<li><!-- raw HTML omitted -->logb a &lt; d   ====&gt; O(N^d)<!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted -->logb a &gt; b   ====&gt; O(N ^ logb a)<!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted -->logb a == b ====&gt; O(N ^d * logN)<!-- raw HTML omitted --></li>
</ul>
</li>
<li>汉诺塔问题</li>
<li>生成全子序列</li>
<li>生成全排序</li>
<li>对数器方法采用的递归</li>
</ul>
<h2 id="回溯">回溯</h2>
<h3 id="定义">定义</h3>
<pre><code>    * 回溯法也可以叫回溯搜素法，它是一种搜素的方式，在二叉树或者树系列中频繁出现。
    * 回溯是递归的副产品，存在递归的地方就有可能会有回溯。
    * 回溯算法的性能一般，其本质就是穷举，可以通过一些剪枝操作提高效率但是也改变不了穷举的本质。
</code></pre>
<h3 id="解决的问题">解决的问题</h3>
<ul>
<li><strong>搜索问题</strong>：这类问题的目标是找到满足特定条件的解决方案
<ul>
<li>排列问题：N个数按一定的规则全排列，有几种排列方式</li>
<li>组合问题：N个数里面按一定的规则找出k个数的集合</li>
<li>子集和问题：一个N个数的集合中有多少符合条件的子集</li>
<li>汉诺塔问题：给定三根柱子和一系列大小不同的圆盘，要求将所有的圆盘从一根柱子移动到另一根柱子，每次只能移动一个圆盘，且不能将大圆盘放在小圆盘上</li>
<li>切割问题：一个字符串按一定的规则有几种切割方式</li>
</ul>
</li>
<li>**约束满足问题 **：这类问题的目标是找到所有满足约束条件的解
<ul>
<li>n皇后：在N*N的棋盘上放置N个皇后，使得它们互不攻击</li>
<li>数独：在9<em>9的网格中填入1-9，使得每行，每列和每个3</em>3子网格的数字不重复</li>
<li>图着色问题：给定一个无向图，用最少的颜色给图的每个顶点着色，使得相邻顶点颜色不同</li>
</ul>
</li>
<li><strong>组合优化问题</strong>：这类问题的目标是在一个组合空间中找到满足某些条件的最优解
<ul>
<li>0-1背包问题：给定一组物品和一个背包，每个物品有一定的价值和重量，要求在背包容量限制内，选择物品使得总价值最大。</li>
<li>旅行商问题：在一个图中，从一个点触发访问所有其他点恰好一次后返回起点，求最短路径。</li>
<li>最大图问题：给定一个无向图，找到最大的完全子图，即子图中的任意两个顶点之间都有边相连。</li>
<li><strong>注意</strong>：对于很多组合优化问题，回溯不是最优解决方案。
<ul>
<li>0-1背包问题：通常使用动态规划解决，以达到更高的事件效率。</li>
<li>旅行商问题是一个著名的NP-Hard问题，常用的解法有遗传算法和蚁群算法等。</li>
<li>最大团问题是图论中的一个经典问题，可用贪心算法等启发式算法来解决。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="二经典题解">二、经典题解</h1>
<h2 id="通用模板">通用模板</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">void</span><span class="w"> </span><span class="nf">backtrack</span><span class="w"> </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Choice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">choices</span><span class="p">,</span><span class="n">List</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span><span class="w"> </span><span class="n">res</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//判断是否为解</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">isSolution</span><span class="p">(</span><span class="n">state</span><span class="p">)){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//记录解</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">recordSolution</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">res</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">retrun</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//遍历所有选择</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">Choice</span><span class="w"> </span><span class="n">choice</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">choices</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//剪枝:判断选择是否合法</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">isValid</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">choice</span><span class="p">)){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//尝试做出选择，更新状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">makeChoice</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">choice</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">backtrack</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">choice</span><span class="p">,</span><span class="n">res</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//回退;撤销选择，恢复到之前的状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">undoChoice</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">choice</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="1全排列问题">1、全排列问题</h2>
<p>全排列问题是一个回溯算法的典型应用。它的定义是在给定一个集合（如一个数组或字符串）的情况下，找出其中元素的所有可能的排列。</p>
<p><strong>示例数据</strong>：</p>
<table>
<thead>
<tr>
<th>输入数组</th>
<th>输出数组</th>
</tr>
</thead>
<tbody>
<tr>
<td>[1,2]</td>
<td>[1,2],[2,1]</td>
</tr>
<tr>
<td>[1,2,3]</td>
<td>[1,2,3],[1,3,2],[2,1,3],[3,1,2],[3,2,1]</td>
</tr>
</tbody>
</table>
<p><strong>1、无相等元素情况</strong></p>
<blockquote>
<p>输入一个整数数组，其中不包含重复元素，返回所有可能的排列。</p>
</blockquote>
<p><strong>思路</strong></p>
<p>从回溯算法的角度看，我们可以把生成排列的过程想象成一系列选择的结果；</p>
<p>假设输入数组为[1,2,3],如果我们先选择1，再选择3,最后选择2，则获得排列[1,3,2]。回退表示撤销一个选择，之后继续尝试其他选择。</p>
<ul>
<li>choose和state选择
<ul>
<li>chooses表示输入的数组，state表示当前状态（当前组合中数的集合），因为输入数组不重复，且每个数只允许选择一次，所以state中的元素表示唯一。</li>
</ul>
</li>
<li>剪枝
<ul>
<li>为了实现每个元素只被选择一次，我们考虑引入一个boolean类型数组selected[i]，来记录数组是否被选择过。</li>
<li>遍历选择列表choices时，跳过所有已被选择的节点，即剪枝。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     *  全排列递归回溯
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param nums 输入数组
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param state 临时记录
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param res 结果集
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param selected 临时记录中所选元素
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">backTrack</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">nums</span><span class="p">,</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w">  </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">res</span><span class="p">,</span><span class="kt">boolean</span><span class="o">[]</span><span class="w"> </span><span class="n">selected</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//判断是否为解</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="na">length</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//记录解 拷贝一份记录</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">res</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">state</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//遍历所有选择</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">selected</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">continue</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">state</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">num</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">selected</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">backTrack</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span><span class="n">state</span><span class="p">,</span><span class="n">res</span><span class="p">,</span><span class="n">selected</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//回溯 移除最后添加的元素</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">state</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">selected</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>2、存在相等元素</strong></p>
<blockquote>
<p>通过一个Set来记录对应结果集选择的元素，让每次选择的重复元素进行剪枝，保证这次选择中相等的元素只被选择一次。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     *  全排列递归回溯 输入存在重复元素
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param nums 输入数组
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param state 临时记录
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param res 结果集
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param selected 临时记录中所选元素
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">backTrack2</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">nums</span><span class="p">,</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w">  </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">res</span><span class="p">,</span><span class="kt">boolean</span><span class="o">[]</span><span class="w"> </span><span class="n">selected</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//判断是否为解</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="na">length</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//记录解 拷贝一份记录</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">res</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">state</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">repeatNum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashSet</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//遍历所有选择</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">selected</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">repeatNum</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="n">num</span><span class="p">)){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">continue</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">state</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">num</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">repeatNum</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">num</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">selected</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">backTrack2</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span><span class="n">state</span><span class="p">,</span><span class="n">res</span><span class="p">,</span><span class="n">selected</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//回溯 移除最后添加的元素</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">state</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">selected</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="2子集合问题">2、子集合问题</h2>
<blockquote>
<p>给定一个集合，和一个目标值，返回符合条件合为目标值的子集合；</p>
</blockquote>
<ul>
<li>思路
<ul>
<li>1、可以看作是在全排列的基础上，通过目标值进行选择；</li>
<li>2、因为元素可以重复选择，所以可以不用boolean来记录是否选择；</li>
<li>3、因为需要排除元素相同顺序不同的集合，所以将集合排序，传入下次遍历的开始索引（限定遍历顺序，只能从前往后选择，且元素不重复）。</li>
</ul>
</li>
</ul>
<p><strong>无重复元素</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 无重复元素 子集合实现 （先行排序，然后通过传递遍历下标的形式去排除 重复子集合）
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param nums
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param tempRes
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param res
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param target
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">backTrack</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">nums</span><span class="p">,</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tempRes</span><span class="p">,</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">res</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">target</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//记录解</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">target</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">0</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">res</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">tempRes</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//剪枝</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">target</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">0</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">continue</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">tempRes</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">num</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">backTrack</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span><span class="n">tempRes</span><span class="p">,</span><span class="n">res</span><span class="p">,</span><span class="n">target</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="n">i</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//回溯</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">tempRes</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">tempRes</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>重复元素情况</strong></p>
<blockquote>
<p>题目的变种，集合中每个元素只能被选择一次，但是集合中存在重复的元素。</p>
</blockquote>
<ul>
<li>思考
<ul>
<li>1、在无重复元素的基础上进行改造；每个元素只能被选择一次
<ul>
<li>传入的下一个元素的下标只能是当前下标 + 1</li>
</ul>
</li>
<li>2、每次选择重复元素只能被选择一次
<ul>
<li>输入集合排序之后，在进行遍历选择的时候，当前元素如果等于上一个元素则跳过</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="w"> </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     *  输入集合存在重复，且每个元素只被选择一次
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param nums
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param tempRes
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param res
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param target
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param index
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">backTrack2</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">nums</span><span class="p">,</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tempRes</span><span class="p">,</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">res</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">target</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//记录解</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">target</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">0</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">res</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">tempRes</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">pre</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//剪枝</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">target</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">pre</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">num</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">continue</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">pre</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">tempRes</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">num</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">backTrack2</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span><span class="n">tempRes</span><span class="p">,</span><span class="n">res</span><span class="p">,</span><span class="n">target</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//回溯</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">tempRes</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">tempRes</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="3n皇后问题">3、n皇后问题</h2>
<blockquote>
<p>根据国际象棋规定，皇后可以对其所在行、列、斜线的棋子进行攻击，现在给你n个皇后和n*n大小的棋盘，找到所有皇后之间无法攻击的摆放方案。</p>
</blockquote>
<p><!-- raw HTML omitted -->如图 13-15 所示，当<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->n<!-- raw HTML omitted --><!-- raw HTML omitted -->=<!-- raw HTML omitted --><!-- raw HTML omitted -->4<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->时，共可以找到两个解。从回溯算法的角度看，<!-- raw HTML omitted --><!-- raw HTML omitted -->n<!-- raw HTML omitted --><!-- raw HTML omitted -->×<!-- raw HTML omitted --><!-- raw HTML omitted -->n<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->大小的棋盘共有<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->n<!-- raw HTML omitted --><!-- raw HTML omitted -->2<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->个格子，给出了所有的选择<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><code>choices</code><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->。在逐个放置皇后的过程中，棋盘状态在不断地变化，每个时刻的棋盘就是状态<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><code>state</code><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->。<!-- raw HTML omitted --></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/22648511/1729317621014-2847d888-1b01-41d0-a74e-189d7ef5270d.png" alt=""></p>
<p><!-- raw HTML omitted -->为了满足列约束，我们可以利用一个长度为<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->n<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->的布尔型数组<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><code>cols</code><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->记录每一列是否有皇后。在每次决定放置前，我们通过<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><code>cols</code><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->将已有皇后的列进行剪枝，并在回溯中动态更新<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><code>cols</code><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->的状态。<!-- raw HTML omitted --></p>
<p><strong><!-- raw HTML omitted -->Tip<!-- raw HTML omitted --></strong></p>
<p><!-- raw HTML omitted -->请注意，矩阵的起点位于左上角，其中行索引从上到下增加，列索引从左到右增加。<!-- raw HTML omitted --></p>
<p><!-- raw HTML omitted -->那么，如何处理对角线约束呢？设棋盘中某个格子的行列索引为<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->(<!-- raw HTML omitted --><!-- raw HTML omitted -->r<!-- raw HTML omitted --><!-- raw HTML omitted -->o<!-- raw HTML omitted --><!-- raw HTML omitted -->w<!-- raw HTML omitted --><!-- raw HTML omitted -->,<!-- raw HTML omitted --><!-- raw HTML omitted -->c<!-- raw HTML omitted --><!-- raw HTML omitted -->o<!-- raw HTML omitted --><!-- raw HTML omitted -->l<!-- raw HTML omitted --><!-- raw HTML omitted -->)<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->，选定矩阵中的某条主对角线，我们发现该对角线上所有格子的行索引减列索引都相等，<!-- raw HTML omitted --><strong><!-- raw HTML omitted -->即主对角线上所有格子的<!-- raw HTML omitted --><strong><strong><!-- raw HTML omitted --> <!-- raw HTML omitted --></strong></strong><!-- raw HTML omitted -->r<!-- raw HTML omitted --><strong><strong><!-- raw HTML omitted -->o<!-- raw HTML omitted --></strong></strong><!-- raw HTML omitted -->w<!-- raw HTML omitted --><strong><strong><!-- raw HTML omitted -->−<!-- raw HTML omitted --></strong></strong><!-- raw HTML omitted -->c<!-- raw HTML omitted --><strong><strong><!-- raw HTML omitted -->o<!-- raw HTML omitted --></strong></strong><!-- raw HTML omitted -->l<!-- raw HTML omitted --><strong><strong><!-- raw HTML omitted --> <!-- raw HTML omitted --></strong></strong><!-- raw HTML omitted -->为恒定值<!-- raw HTML omitted --></strong><!-- raw HTML omitted -->。<!-- raw HTML omitted --></p>
<p><!-- raw HTML omitted -->也就是说，如果两个格子满足<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->r<!-- raw HTML omitted --><!-- raw HTML omitted -->o<!-- raw HTML omitted --><!-- raw HTML omitted -->w<!-- raw HTML omitted --><!-- raw HTML omitted -->1<!-- raw HTML omitted --><!-- raw HTML omitted -->−<!-- raw HTML omitted --><!-- raw HTML omitted -->c<!-- raw HTML omitted --><!-- raw HTML omitted -->o<!-- raw HTML omitted --><!-- raw HTML omitted -->l<!-- raw HTML omitted --><!-- raw HTML omitted -->1<!-- raw HTML omitted --><!-- raw HTML omitted -->=<!-- raw HTML omitted --><!-- raw HTML omitted -->r<!-- raw HTML omitted --><!-- raw HTML omitted -->o<!-- raw HTML omitted --><!-- raw HTML omitted -->w<!-- raw HTML omitted --><!-- raw HTML omitted -->2<!-- raw HTML omitted --><!-- raw HTML omitted -->−<!-- raw HTML omitted --><!-- raw HTML omitted -->c<!-- raw HTML omitted --><!-- raw HTML omitted -->o<!-- raw HTML omitted --><!-- raw HTML omitted -->l<!-- raw HTML omitted --><!-- raw HTML omitted -->2<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->，则它们一定处在同一条主对角线上。利用该规律，我们可以借助图 13-18 所示的数组<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><code>diags1</code><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->记录每条主对角线上是否有皇后。<!-- raw HTML omitted --></p>
<p><!-- raw HTML omitted -->同理，<!-- raw HTML omitted --><strong><!-- raw HTML omitted -->次对角线上的所有格子的<!-- raw HTML omitted --><strong><strong><!-- raw HTML omitted --> <!-- raw HTML omitted --></strong></strong><!-- raw HTML omitted -->r<!-- raw HTML omitted --><strong><strong><!-- raw HTML omitted -->o<!-- raw HTML omitted --></strong></strong><!-- raw HTML omitted -->w<!-- raw HTML omitted --><strong><strong><!-- raw HTML omitted -->+<!-- raw HTML omitted --></strong></strong><!-- raw HTML omitted -->c<!-- raw HTML omitted --><strong><strong><!-- raw HTML omitted -->o<!-- raw HTML omitted --></strong></strong><!-- raw HTML omitted -->l<!-- raw HTML omitted --><strong><strong><!-- raw HTML omitted --> <!-- raw HTML omitted --></strong></strong><!-- raw HTML omitted -->是恒定值<!-- raw HTML omitted --></strong><!-- raw HTML omitted -->。我们同样也可以借助数组<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><code>diags2</code><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->来处理次对角线约束。<!-- raw HTML omitted --></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/22648511/1729332291714-d09382ba-c101-43a5-a16f-080472884bba.png" alt=""></p>
<p><!-- raw HTML omitted -->图 13-18   处理列约束和对角线约束<!-- raw HTML omitted --></p>
<ul>
<li>思路
<ul>
<li>限制条件
<ul>
<li>每行只能存在一个皇后</li>
<li>每列只能存在一个皇后</li>
<li>每个对角线只能存在一个皇后</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * N皇后问题
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param res
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param row 遍历的行数（由规则可知，每行只存在一个皇后，所以以行为固定参数进行遍历）
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param n 总行数(遍历到最后一行，记录符合条件的数据集)
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param temRes 临时数组，存储数据集
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param clos 列标记(标记被攻击的列)
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param dag1 正向对角线标记(标记被攻击的正向对角线) 对角线数量是 2*n - 1 该位置的对角线是 dag1 = row - clo + n - 1
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param dag2 反向对角线标记(标记被攻击的反向对角线) 正反向对角线数量相同，该位置对角线是 dag2 = row + clo；
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">backtrack</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">res</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">temRes</span><span class="p">,</span><span class="kt">boolean</span><span class="o">[]</span><span class="w"> </span><span class="n">clos</span><span class="p">,</span><span class="kt">boolean</span><span class="o">[]</span><span class="w"> </span><span class="n">dag1</span><span class="p">,</span><span class="kt">boolean</span><span class="o">[]</span><span class="w"> </span><span class="n">dag2</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">row</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">res</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">temRes</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">clo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">clo</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">clo</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//剪枝 判断当前位置是否被皇后攻击</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">clos</span><span class="o">[</span><span class="n">clo</span><span class="o">]</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">dag1</span><span class="o">[</span><span class="n">row</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">clo</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">dag2</span><span class="o">[</span><span class="n">row</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">clo</span><span class="o">]</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">continue</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">temRes</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">clo</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">clos</span><span class="o">[</span><span class="n">clo</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dag1</span><span class="o">[</span><span class="n">row</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">clo</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dag2</span><span class="o">[</span><span class="n">row</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">clo</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">backtrack</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">row</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">temRes</span><span class="p">,</span><span class="n">clos</span><span class="p">,</span><span class="n">dag1</span><span class="p">,</span><span class="n">dag2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//递归</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">temRes</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">temRes</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//回溯</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">clos</span><span class="o">[</span><span class="n">clo</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dag1</span><span class="o">[</span><span class="n">row</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">clo</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dag2</span><span class="o">[</span><span class="n">row</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">clo</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h1 id="三实例">三、实例</h1>
<h2 id="1普通递归">1、普通递归</h2>
<blockquote>
<p>给一组数，求其中的最大数</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">getMax</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">arr</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">process</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="n">0</span><span class="p">,</span><span class="n">arr</span><span class="p">.</span><span class="na">length</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">right</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//通过位运算计算中间值有两个好处</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//1、有效避免了整数类型的溢出</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//2、在硬件层面来说位运算比除指令效率更高</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">((</span><span class="n">right</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">left</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">leftMax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">process</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="n">left</span><span class="p">,</span><span class="n">mid</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">rightMax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">process</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">left</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Matn</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">leftMax</span><span class="p">,</span><span class="n">rightMax</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>Master公式</p>
<p>T(N) = 2 * T(n/2) + O(1)</p>
<p>log2 2 == 1</p>
<p>T(N) = O(N ^ logb a);</p>
</blockquote>
<h2 id="2递归回溯剪枝">2、递归回溯剪枝</h2>
<blockquote>
<p>给定一个数组A{2,3,6,7}和一个数B，要求输出数组A中构成B的数，且数组A中的数可重复出现。</p>
<p>输出:{2,2,3},{7}</p>
</blockquote>
<p>思路：</p>
<ul>
<li>排序和剪枝
<ul>
<li>首先对数组A进行排序，这样可以在后续遍历的过程中方便进行剪枝处理，减少不必要的搜索。</li>
</ul>
</li>
<li>回溯算法
<ul>
<li>使用回溯算法探索所有可能组合。
<ul>
<li>回溯算法是一种递归的深度优先搜索方法，用于解决组合问题。</li>
</ul>
</li>
<li>维护一个当前组合集，递归添加数据， 回溯移除数据，直到组合的和等于目标数，或超过目标数（进行剪枝）</li>
</ul>
</li>
<li>回溯的过程
<ul>
<li>通过下标选定最小的元素，往组合中添加，如果组合值和目标值的差值小于当前元素，则移除最后加入的元素，尝试下一个元素，直到所有可能的组合都被尝试完毕。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">args</span><span class="o">[]</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="p">{</span><span class="n">2</span><span class="p">,</span><span class="n">3</span><span class="p">,</span><span class="n">5</span><span class="p">,</span><span class="n">7</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">7</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Arrays</span><span class="p">.</span><span class="na">sort</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">resultList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">combine</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">currentList</span><span class="p">,</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">result</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">0</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//通过创建集合的方式去更改currentList的引用</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">resultList</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">currentList</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//如果当前值超过b，则说明组合值大于b，进行剪枝</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">currentList</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//递归 ：递归加入当前位置的值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">combine</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">currentList</span><span class="p">,</span><span class="n">resultList</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//回溯 ：如果当前组合的值于目标值的差值小于当前位置的值，进行回溯并选取下一位置的值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">currentList</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">currentList</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>
      </div>
    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
    
      <script>
  document.addEventListener('DOMContentLoaded', function() {
    const tocElement = document.querySelector('.post-toc');
    if (tocElement) {
      const tocTitle = tocElement.querySelector('.post-toc-title');
      
      
      if (window.innerWidth <= 768) {
        tocTitle.addEventListener('click', function() {
          tocElement.classList.toggle('active');
        });
      }
      
      
      const tocLinks = tocElement.querySelectorAll('a');
      tocLinks.forEach(link => {
        link.addEventListener('click', function(e) {
          e.preventDefault();
          const targetId = this.getAttribute('href').substring(1);
          const targetElement = document.getElementById(targetId);
          
          if (targetElement) {
            window.scrollTo({
              top: targetElement.offsetTop - 20,
              behavior: 'smooth'
            });
            
            
            if (window.innerWidth <= 768) {
              tocElement.classList.remove('active');
            }
          }
        });
      });
    }
  });
</script>
    
    
    
    
    <script src="/static/js/back-button.min.fc91a7f6baac199fdacc77cc4db320ef5d39d48fd68258cbef8d1ccf2e6b8ea0.js" defer></script>
  </body>
</html>
