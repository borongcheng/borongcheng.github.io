+++
date = "2025-09-11T14:00:54"
title = "最小生成树"
tags = ["算法"]
+++
# 一、定义
最小生成树（Minimum Spancning Tree），是指在一个连接加权无向图中找到一个树（即无环连通子图），使得这个树包含所有顶点，且所有边的加权值合最小。



# 二、**经典解题**
## Prim
+ prim算法
    - prim算法是一种生成最小生成树的贪心算法，基本思想是从一个初始顶点逐步将图中的顶点加入到当前最小生成树中，直到包含了所有顶点且不构成环。具体步骤如下：
        * 选择初始顶点
            + 选择初始顶点：在图中选择任意一顶点作为初始顶点，将其加入到最小生成树的集合中。
            + 找到最小边：从当前已经构建的最小生成树的顶点集合出发，选择一条未加入树中的且连接值为最小的顶点进行连接，将这个顶点加入到最小生成树集合中。
            + 重复找最小边的步骤：重复步骤2直到所有顶点都加入到了最小生成树中。
    - 总结：Prim算法通过不断扩展最小生成树集合，并选择连接集合的最小值点，来逐步构建整个最小生成树，直到包含了整个顶点。

### 图形实现
> 选择无向图任意一个点作为顶点，例如选择v1
>

![](https://cdn.nlark.com/yuque/0/2024/png/22648511/1722404003769-73d7d757-aedd-4b74-8b05-35051d6bb368.png)

> 从v1出发有三条边，我们选择权重最小的那条，连接v1-v3
>

![](https://cdn.nlark.com/yuque/0/2024/png/22648511/1722404010776-1151c3ef-b6e9-495e-91f1-6d82cd59fa2f.png)

> 此时将v1和v3看成一个整体，从整体出发有6条边，选择最小一条，构成v1-v3-v6连接
>

![](https://cdn.nlark.com/yuque/0/2024/png/22648511/1722404017973-6147a0ec-2347-4cdb-b0e5-618622d7ea67.png)

> 继续选择最小一条，构成v1-v3-v6-v4连接
>

![](https://cdn.nlark.com/yuque/0/2024/png/22648511/1722404023993-f7a3139c-9c9c-4cab-85b1-4e20cf910f9c.png)

> v1-v3-v6-v4整体出发，有三条边都为5，且是最小，但是v4-v3和v4-v1两条边会构成回环，所以选择v2构成v1-v3-v6-v4-v2一个整体
>

![](https://cdn.nlark.com/yuque/0/2024/png/22648511/1722404412274-677b54b1-a513-4511-8545-32da555c93e3.png)

> 继续选择最小的边构成v1-v3-v6-v4-v2-v5
>

![](https://cdn.nlark.com/yuque/0/2024/png/22648511/1722404435212-78dac1e2-c324-42ab-af5b-f8a4c290dad2.png)

### 算法实现
题目：

![](https://cdn.nlark.com/yuque/0/2024/png/22648511/1722407009870-17741501-7d51-41a1-87f4-6c74e903652c.png)

> 输入：
>
> 3
>
> 3
>
> 1 2 3 0
>
> 1 3 1 0
>
> 2 3 5 0
>
> 输出：
>
> 4
>
> 说明：
>
> 只需要在1-2，1-3之间铺设光纤，其成本为3+1 = 4；
>

```java
public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        while (in.hasNextInt()) { // 注意 while 处理多个 case
            int n = in.nextInt();//基站个数
            int m = in.nextInt();//具备光纤直连条件的基站对数

            int[][] graph = new int[n + 1][n + 1];
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= n; j++) {
                    //初始化 默认基站不连通，权值最大
                    graph[i][j] = Integer.MAX_VALUE;
                }
            }

            for (int i = 0; i < m; i++) {
                int x = in.nextInt();
                int y = in.nextInt();
                int z = in.nextInt();
                int p = in.nextInt();

                if(p == 0){
                    //将连接的权重保存到二维数组中
                    graph[x][y] = z;
                    graph[y][x] = z;
                }else {
                    //如果存在连接则记录为0
                    graph[x][y] = 0;
                    graph[y][x] = 0;
                }
            }
            System.out.println(print(graph,n));
        }
    }

    public static int print(int[][] graph,int n){
        //记录最小生成树的总权重
        int weight = 0;

        //表示第i个基站是否存在最小生成树之中
        boolean[] check = new boolean[n + 1];
        //选择第一个基站为初始顶点
        check[1] = true;

        //记录最小生成树里面存在的节点树
        int minCount = 1;

        //dis[i] 表示第i个节点到最小生成树集合的最小位置
        int[] dis = new int[n + 1];

        for (int i = 1; i <= n; i++) {
            //在初始化时，最小生成树集合里面只有节点1，所以dis数组存储的就是其他节点到节点1的距离
            dis[i] = graph[1][i];
        }

        //循环查找最小生成树节点，如果节点到了n则跳出
        while (minCount < n){
            //记录最小权值的字段
            int minDis = Integer.MAX_VALUE;
            //记录最小权值所在位置
            int nodeIdx = 0;
            for (int i = 1; i <= n; i++) {
                //当前点不在最小生成树集合中
                //且当前位置的权值小于记录的最小权值
                if (!check[i] && dis[i] < minDis){
                    //更新最小权值
                    minDis = dis[i];
                    //记录位点
                    nodeIdx = i;
                }
            }

            //如果位点还是0，表示剩下的节点不与最小生成树关联
            if (nodeIdx == 0){
                return  -1;
            }
            //如果存在节点，将节点加入最小生成树集合
            check[nodeIdx] = true;
            //更新最小生成树集合内节点数量
            minCount++;
            //更新最小生成树总权值
            weight += dis[nodeIdx];

            //第一次初始化时，我们选择的节点1作为最小生成树的初始节点，所以dis[i]数组记录的是第i个节点到1节点的最小权值
            //后续遍历中，最小生成树会加入节点不再是只有1，所以dis[i]数组记录的是第i个节点到最小生成树整体的最小权值。
            for (int i = 0; i <= n; i++) {
                //当前节点不在最小生成树中时
                //将前一步拿到的最小生成树节点位置，nodeIdx与dis数组里面维护的之前的最小值比较，更新最小值
                if(!check[i] && graph[nodeIdx][i] < dis[i]){
                    //如果进入这个方法，则说明
                    //1、当前节点不在最小生成数集合中
                    //2、i到当前节点nodeIdx的权值，比最小生成树里除nodeIdx外其他节点到i的权值都小
                    //3、更新维护最小的权值，当下一轮nodeIdx拿到时在继续比较更新
                    dis[i] = graph[nodeIdx][i];
                }
            }
        }
        return weight;
    }
```

## Kruskal
+ kruskal算法
    - Krushkal算法是另外一种生成最小生成树的算法，它是基于边来构成的而不是顶点。具体步骤如下：
        * 初始化：将图中所有边按照权值从小到达排序。
        * 创建并查集：初始化一个并查集（Union-Find），用来帮助管理顶点的连接关系避免形成环路，并查集主要有两个操作：
            + Find ：查找出元素所在的集合。
            + Union：将两个集合并合成一个集合。
        * 遍历边集合：按照排好序的边集合进行遍历。
        * 添加到最小生成树：对于每条边，检查其两个顶点是否已经在同一个连通分量中（即同一个集合中），如果不在同一个集合中，则将这两条边加入最小生成树的集合中，并合并这两个顶点所在的集合。
        * 继续遍历：直到最小生成树集合包含了所有的顶点为止，或者边集合遍历完毕。
        * 结束：当边集合遍历完毕，最小生成树集合就构建完了。
    - 总结：通过选择图中最小权值的边，并保证添加这条边不会形成环路，逐步构建出最小生成树。
        * 核心思想是根据贪心策略选择最小边，并使用并查集来维护和判断顶点之间的关系，从而达到构成最小生成树的目的。

## Boruvka
+ Boruvka算法
    - Boruvka是一种生成最小生成树的算法，它的思路更接近于分步逼近合并行处理。具体步骤如下：
        * 初始化：将每个顶点都视为一个独立的树（或者称为森林），每个树包含一个顶点。
        * 迭代过程：
            + 步骤1:对于每棵树，从该树的每个顶点出发，找到连接其他树中权值最小的边。这些边称为最小边或者轻边。
            + 步骤2:将所有最小边加入到最小生成树集合中。
        * 合并树：
            + 对每个树进行合并，使得连接这些最小边的顶点所在的树合并成更大的树。（合并过程类似并查集中的Union操作）
        * 重复：重复步骤1、2直到所有顶点都在同一棵最小生成树上。
    - 总结
        * 分步找到各个顶点的最小边，然后逐步合并这些边所连接的顶点，从而构成最小生成树。

