<!doctype html>
<html lang="zh-CN">
  <head>
    <title>最小生成树 // 笔记网站</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.121.0">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="borong.cheng" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/static/css/main.min.b84e0970f1042270e748e500e667d336cc11fd43e14b8fd28a91b688e487575c.css" />
    

    
    <meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://borongcheng.github.io/static/%E9%A6%96%E9%A1%B5%E4%B8%AD%E9%97%B4%E7%9A%84%E5%9B%BE%E7%89%87" /><meta name="twitter:title" content="最小生成树"/>
<meta name="twitter:description" content="一、定义 最小生成树（Minimum Spancning Tree），是指在一个连接加权无向图中找到一个树（即无环连通子图），使得这个树包含所有顶点，且所有边的加"/>

    <meta property="og:title" content="最小生成树" />
<meta property="og:description" content="一、定义 最小生成树（Minimum Spancning Tree），是指在一个连接加权无向图中找到一个树（即无环连通子图），使得这个树包含所有顶点，且所有边的加" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://borongcheng.github.io/static/specialized/algorithm/21%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" /><meta property="og:image" content="https://borongcheng.github.io/static/%E9%A6%96%E9%A1%B5%E4%B8%AD%E9%97%B4%E7%9A%84%E5%9B%BE%E7%89%87" /><meta property="article:section" content="specialized" />
<meta property="article:published_time" content="2025-09-11T14:00:54+00:00" />
<meta property="article:modified_time" content="2025-09-11T14:00:54+00:00" /><meta property="og:site_name" content="柏荣的博客" />



  </head>
  <body>
    <header class="app-header">
      <a href="https://borongcheng.github.io/static/"><img class="app-header-avatar" src="/static/picture/daji.jpg" alt="borong.cheng" /></a>
      <span class="app-header-title">笔记网站</span>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/static/">Home</a>
             - 
          
          <a class="app-header-menu-item" href="/static/categories/">类别</a>
             - 
          
          <a class="app-header-menu-item" href="/static/tags/">Tags</a>
      </nav>
      <p>柏荣的博客</p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">最小生成树</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Sep 11, 2025
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          5 min read
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://borongcheng.github.io/static/tags/%E7%AE%97%E6%B3%95/">算法</a>
        </div>
      </div>
    </header>
    <div class="post-container">
      <div class="post-toc-container">
        
<div class="post-toc">
  <div class="post-toc-title">目录</div>
  <div class="post-toc-content">
    
    <nav>
  <ul>
    <li><a href="#prim">Prim</a>
      <ul>
        <li><a href="#图形实现">图形实现</a></li>
        <li><a href="#算法实现">算法实现</a></li>
      </ul>
    </li>
    <li><a href="#kruskal">Kruskal</a></li>
    <li><a href="#boruvka">Boruvka</a></li>
  </ul>
</nav>
  </div>
</div>

      </div>
      <div class="post-content">
        <h1 id="一定义">一、定义</h1>
<p>最小生成树（Minimum Spancning Tree），是指在一个连接加权无向图中找到一个树（即无环连通子图），使得这个树包含所有顶点，且所有边的加权值合最小。</p>
<h1 id="二经典解题">二、<strong>经典解题</strong></h1>
<h2 id="prim">Prim</h2>
<ul>
<li>prim算法
<ul>
<li>prim算法是一种生成最小生成树的贪心算法，基本思想是从一个初始顶点逐步将图中的顶点加入到当前最小生成树中，直到包含了所有顶点且不构成环。具体步骤如下：
<ul>
<li>选择初始顶点
<ul>
<li>选择初始顶点：在图中选择任意一顶点作为初始顶点，将其加入到最小生成树的集合中。</li>
<li>找到最小边：从当前已经构建的最小生成树的顶点集合出发，选择一条未加入树中的且连接值为最小的顶点进行连接，将这个顶点加入到最小生成树集合中。</li>
<li>重复找最小边的步骤：重复步骤2直到所有顶点都加入到了最小生成树中。</li>
</ul>
</li>
</ul>
</li>
<li>总结：Prim算法通过不断扩展最小生成树集合，并选择连接集合的最小值点，来逐步构建整个最小生成树，直到包含了整个顶点。</li>
</ul>
</li>
</ul>
<h3 id="图形实现">图形实现</h3>
<blockquote>
<p>选择无向图任意一个点作为顶点，例如选择v1</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/22648511/1722404003769-73d7d757-aedd-4b74-8b05-35051d6bb368.png" alt=""></p>
<blockquote>
<p>从v1出发有三条边，我们选择权重最小的那条，连接v1-v3</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/22648511/1722404010776-1151c3ef-b6e9-495e-91f1-6d82cd59fa2f.png" alt=""></p>
<blockquote>
<p>此时将v1和v3看成一个整体，从整体出发有6条边，选择最小一条，构成v1-v3-v6连接</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/22648511/1722404017973-6147a0ec-2347-4cdb-b0e5-618622d7ea67.png" alt=""></p>
<blockquote>
<p>继续选择最小一条，构成v1-v3-v6-v4连接</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/22648511/1722404023993-f7a3139c-9c9c-4cab-85b1-4e20cf910f9c.png" alt=""></p>
<blockquote>
<p>v1-v3-v6-v4整体出发，有三条边都为5，且是最小，但是v4-v3和v4-v1两条边会构成回环，所以选择v2构成v1-v3-v6-v4-v2一个整体</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/22648511/1722404412274-677b54b1-a513-4511-8545-32da555c93e3.png" alt=""></p>
<blockquote>
<p>继续选择最小的边构成v1-v3-v6-v4-v2-v5</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/22648511/1722404435212-78dac1e2-c324-42ab-af5b-f8a4c290dad2.png" alt=""></p>
<h3 id="算法实现">算法实现</h3>
<p>题目：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/22648511/1722407009870-17741501-7d51-41a1-87f4-6c74e903652c.png" alt=""></p>
<blockquote>
<p>输入：</p>
<p>3</p>
<p>3</p>
<p>1 2 3 0</p>
<p>1 3 1 0</p>
<p>2 3 5 0</p>
<p>输出：</p>
<p>4</p>
<p>说明：</p>
<p>只需要在1-2，1-3之间铺设光纤，其成本为3+1 = 4；</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span><span class="lnt">98
</span><span class="lnt">99
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Scanner</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Scanner</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">in</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 注意 hasNext 和 hasNextLine 的区别</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="na">hasNextInt</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 注意 while 处理多个 case</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="na">nextInt</span><span class="p">();</span><span class="c1">//基站个数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="na">nextInt</span><span class="p">();</span><span class="c1">//具备光纤直连条件的基站对数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">graph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">][</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">//初始化 默认基站不连通，权值最大</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">graph</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Integer</span><span class="p">.</span><span class="na">MAX_VALUE</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="na">nextInt</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="na">nextInt</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="na">nextInt</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="na">nextInt</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">0</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">//将连接的权重保存到二维数组中</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">graph</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">graph</span><span class="o">[</span><span class="n">y</span><span class="o">][</span><span class="n">x</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">//如果存在连接则记录为0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">graph</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">graph</span><span class="o">[</span><span class="n">y</span><span class="o">][</span><span class="n">x</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">print</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="n">n</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">graph</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//记录最小生成树的总权重</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//表示第i个基站是否存在最小生成树之中</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">boolean</span><span class="o">[]</span><span class="w"> </span><span class="n">check</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//选择第一个基站为初始顶点</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">check</span><span class="o">[</span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//记录最小生成树里面存在的节点树</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">minCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//dis[i] 表示第i个节点到最小生成树集合的最小位置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">dis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//在初始化时，最小生成树集合里面只有节点1，所以dis数组存储的就是其他节点到节点1的距离</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">dis</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">graph</span><span class="o">[</span><span class="n">1</span><span class="o">][</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//循环查找最小生成树节点，如果节点到了n则跳出</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">minCount</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//记录最小权值的字段</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">minDis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Integer</span><span class="p">.</span><span class="na">MAX_VALUE</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//记录最小权值所在位置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">nodeIdx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">//当前点不在最小生成树集合中</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">//且当前位置的权值小于记录的最小权值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">check</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">dis</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">minDis</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">//更新最小权值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">minDis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dis</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">//记录位点</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">nodeIdx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//如果位点还是0，表示剩下的节点不与最小生成树关联</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nodeIdx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">0</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w">  </span><span class="o">-</span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//如果存在节点，将节点加入最小生成树集合</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">check</span><span class="o">[</span><span class="n">nodeIdx</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//更新最小生成树集合内节点数量</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">minCount</span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//更新最小生成树总权值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">weight</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dis</span><span class="o">[</span><span class="n">nodeIdx</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//第一次初始化时，我们选择的节点1作为最小生成树的初始节点，所以dis[i]数组记录的是第i个节点到1节点的最小权值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//后续遍历中，最小生成树会加入节点不再是只有1，所以dis[i]数组记录的是第i个节点到最小生成树整体的最小权值。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">//当前节点不在最小生成树中时</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">//将前一步拿到的最小生成树节点位置，nodeIdx与dis数组里面维护的之前的最小值比较，更新最小值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">check</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">graph</span><span class="o">[</span><span class="n">nodeIdx</span><span class="o">][</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dis</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">//如果进入这个方法，则说明</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">//1、当前节点不在最小生成数集合中</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">//2、i到当前节点nodeIdx的权值，比最小生成树里除nodeIdx外其他节点到i的权值都小</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">//3、更新维护最小的权值，当下一轮nodeIdx拿到时在继续比较更新</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">dis</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">graph</span><span class="o">[</span><span class="n">nodeIdx</span><span class="o">][</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="kruskal">Kruskal</h2>
<ul>
<li>kruskal算法
<ul>
<li>Krushkal算法是另外一种生成最小生成树的算法，它是基于边来构成的而不是顶点。具体步骤如下：
<ul>
<li>初始化：将图中所有边按照权值从小到达排序。</li>
<li>创建并查集：初始化一个并查集（Union-Find），用来帮助管理顶点的连接关系避免形成环路，并查集主要有两个操作：
<ul>
<li>Find ：查找出元素所在的集合。</li>
<li>Union：将两个集合并合成一个集合。</li>
</ul>
</li>
<li>遍历边集合：按照排好序的边集合进行遍历。</li>
<li>添加到最小生成树：对于每条边，检查其两个顶点是否已经在同一个连通分量中（即同一个集合中），如果不在同一个集合中，则将这两条边加入最小生成树的集合中，并合并这两个顶点所在的集合。</li>
<li>继续遍历：直到最小生成树集合包含了所有的顶点为止，或者边集合遍历完毕。</li>
<li>结束：当边集合遍历完毕，最小生成树集合就构建完了。</li>
</ul>
</li>
<li>总结：通过选择图中最小权值的边，并保证添加这条边不会形成环路，逐步构建出最小生成树。
<ul>
<li>核心思想是根据贪心策略选择最小边，并使用并查集来维护和判断顶点之间的关系，从而达到构成最小生成树的目的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="boruvka">Boruvka</h2>
<ul>
<li>Boruvka算法
<ul>
<li>Boruvka是一种生成最小生成树的算法，它的思路更接近于分步逼近合并行处理。具体步骤如下：
<ul>
<li>初始化：将每个顶点都视为一个独立的树（或者称为森林），每个树包含一个顶点。</li>
<li>迭代过程：
<ul>
<li>步骤1:对于每棵树，从该树的每个顶点出发，找到连接其他树中权值最小的边。这些边称为最小边或者轻边。</li>
<li>步骤2:将所有最小边加入到最小生成树集合中。</li>
</ul>
</li>
<li>合并树：
<ul>
<li>对每个树进行合并，使得连接这些最小边的顶点所在的树合并成更大的树。（合并过程类似并查集中的Union操作）</li>
</ul>
</li>
<li>重复：重复步骤1、2直到所有顶点都在同一棵最小生成树上。</li>
</ul>
</li>
<li>总结
<ul>
<li>分步找到各个顶点的最小边，然后逐步合并这些边所连接的顶点，从而构成最小生成树。</li>
</ul>
</li>
</ul>
</li>
</ul>

      </div>
    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
    
      <script>
  document.addEventListener('DOMContentLoaded', function() {
    const tocElement = document.querySelector('.post-toc');
    if (tocElement) {
      const tocTitle = tocElement.querySelector('.post-toc-title');
      
      
      if (window.innerWidth <= 768) {
        tocTitle.addEventListener('click', function() {
          tocElement.classList.toggle('active');
        });
      }
      
      
      const tocLinks = tocElement.querySelectorAll('a');
      tocLinks.forEach(link => {
        link.addEventListener('click', function(e) {
          e.preventDefault();
          const targetId = this.getAttribute('href').substring(1);
          const targetElement = document.getElementById(targetId);
          
          if (targetElement) {
            window.scrollTo({
              top: targetElement.offsetTop - 20,
              behavior: 'smooth'
            });
            
            
            if (window.innerWidth <= 768) {
              tocElement.classList.remove('active');
            }
          }
        });
      });
    }
  });
</script>
    
    
    
    
    <script src="/static/js/back-button.min.fc91a7f6baac199fdacc77cc4db320ef5d39d48fd68258cbef8d1ccf2e6b8ea0.js" defer></script>
  </body>
</html>
