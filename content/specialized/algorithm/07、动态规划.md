+++
date = "2025-09-11T14:00:54"
title = "动态规划"
tags = ["算法"]
+++
# 一、定义
1、什么是动态规划？

动态规划（Dynamic programing，简称DP），是一种在数学、管理学科、计算机科学，经济学和生物信息学中使用的，通过把原问题分解成相对简单的子问题的方式来求复杂问题的方法。

动态规划常常适用与有重叠子问题和最优子结构性质的问题。

> dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems.
>

简单来说就是给定一个问题，将这个问题拆解成一个个子问题，直到子问题可以直接解决。然后把子问题的答案保存起来，以减少重复计算。

> 一般这些子问题都可以函数关系式递推出来。然后动态规划致力于每一个子问题解决一次，减少重复的计算，比如斐波那契数列就可以看作入门级的经典动态规划问题。
>

动态规划只能应用于有最优子结构的问题。动态规划中的每一个状态都是由上一个状态推导出来的，这一点区分于贪心算法，贪心没有状态推导，直接从局部选择最优。

> 简单来说，就是将问题分解成子问题，通过求导和存储子问题，到最后合并成主问题的解。
>



2、动态规划应该怎么去解决问题

动态规划包含以下步骤：

+ 确定状态
    - 定义状态：定义问题中的可变参数的状态，可以是一维二维或者更多维的状态，通常反应问题的特征
    - 确定dp数组的含义： 明确每种状态代表的含义，来定义dp多维数组，通过dp数组来记录子问题的解
+ 确定边界条件
    - 确定初始化状态的值，确定递归或者迭代的出口条件
    - dp数组如何初始化
+ 确定递推公式（状态转移方程）
    - 建立状态转移方程：确定任意状态与其相邻状态之间的关系，从而推导出状态转移方程。
    - 递推关系：编写表达式或者方程描述当前状态如何依赖于之前的关系。
+ 计算顺序：
    - 确定计算顺序：一般遵循自底向上或者自顶向下的计算顺序，确保每个子问题的结果被恰当的计算并存储。
    - 子问题求解：通过解决小规模的子问题来逐步求解更大规模的问题，确保动态规划过程的正确性。
+ 实现算法
    - 将以上步骤转化成代码实现，通常使用迭代方式实现状态转移

3、常见的动态规划的题型有哪些？

+ 从左往右尝试模型
    - 背包类型问题
    - 数字字符串转英文字符串
    - 贴纸问题
    - 货币找零方法
    - 货币找零最小张问题
    - 累加和对半数组划分系列问题
+ 区间尝试模型
    - 纸牌游戏
    - 最长回文子序列
+ 样本对应尝试模型
    - 最长公共子序列
    - 最短路径和
    - Bob生存概率问题
    - 砍死怪兽概率问题
    - 分裂数字问题
+ 业务限制尝试模型
    - 机器人行进问题
    - 象棋跳马问题
    - 喝咖啡问题
    - N皇后问题的加速实现

在计算机科学中，动态规划通常用于解决具有重叠子问题具有最优子结构性质的问题。

将原问题分解成相互重叠的子问题，动态规划可以避免重复计算，并以较高的效率求解问题。

# 二、题目
## 一维
### 1、买卖股票的最佳时机
[https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&envId=top-interview-150)

贪心解法：[https://www.yuque.com/tuoyueerwu/ey40ze/gb53dnifmlpzgofn](https://www.yuque.com/tuoyueerwu/ey40ze/gb53dnifmlpzgofn)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给你一个整数数组</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">prices</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，其中 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">prices[i]</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">表示某支股票第</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">i</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">天的价格。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">在每一天，你可以决定是否购买和/或出售股票。你在任何时候 </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">最多</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 只能持有</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">一股</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">股票。你也可以先购买，然后在</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">同一天</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">出售。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">返回 </font>_<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">你能获得的 </font>__**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">最大</font>**__<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 利润</font>_<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">例：</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">prices = [7,1,5,3,6,4]</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">7</font>
>

**步骤**

+ 确定dp数组
    - 题目需要获取的是最后一天结束能的到的最大利润，则记一个天数状态为i
    - 然而题目通过股票的卖出来进行状态转移，且手上最多持有一个股票，即记当前是否持有股票为第二状态。
    - dp[i][0] || dp[i][1] 
+ 状态转移方程
    - 当前状态是通过前一个状态推导而来
    - dp[i][0] 前一天公式
        * dp[i - 1][0] 前一天手持股票也为0，则利润不变化。
            + dp[i][0] = dp[i - 1][0]
        * dp[i - 1][1]前一天手持股票为1，则需要卖出(获得的利润 == 当天的股票价格)
            + dp[i][0] = dp[i - 1][1] + prices[i]
        * **dp[i][0] = max(dp[i - 1][0],dp[i - 1][1] + prices[i]);**
    - dp[i][1]前一天公式
        * dp[i - 1][0] 前一天手持股票为0，买入股票，利润减少当天股票价格
            + dp[i] =  dp[i - 1][0] - prices[i]
        * dp[i - 1][1] 前一天手持股票为1，利润不变
            + dp[i] = dp[i - 1][1]
        * dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])
    - 确定边界条件
        * dp[0][0] = 0,dp[0][1] = -prices[0]
    - 计算顺序
        * 迭代实现

```java
public static int maxProfit(int[] prices) {
        //动态规划
        //确定dp数组  注意----本题当前的状态只依赖上一步推导，所以只需要需要记录上一步的两种可能
        int[][] dp = new int[prices.length][2];
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for (int i = 1; i < prices.length; i++) {
            //状态转移方程
            dp[i][0] = Math.max(dp[i - 1][0],dp[i-1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i- 1][1],dp[i - 1][0] - prices[i]);
        }
        System.out.println(Arrays.deepToString(dp));
        return dp[prices.length- 1][0];
    }
```

### 2、
[https://leetcode.cn/problems/is-subsequence/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/is-subsequence/description/?envType=study-plan-v2&envId=top-interview-150)



### 3、跳跃游戏1
[https://leetcode.cn/problems/jump-game/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/jump-game/description/?envType=study-plan-v2&envId=top-interview-150)

[跳跃游戏-贪心算法](https://www.yuque.com/tuoyueerwu/ey40ze/gb53dnifmlpzgofn#AlHpo)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给你一个非负整数数组 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">nums</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，你最初位于数组的</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">第一个下标</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">。数组中的每个元素代表你在该位置可以跳跃的最大长度。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">判断你是否能够到达最后一个下标，如果可以，返回 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">true</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> ；否则，返回 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">false</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">nums = [2,3,1,1,4]		nums = [3,2,1,0,4]</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">true					false</font>
>

**步骤**

+ 确定状态
    - 最终结果是确定数组最后一个位置是否可以到达
    - 根据当前位置是否可以到达，确定一个boolean类型的dp数组
+ 状态转移
    - dp[i] = dp[j]  && j + nums[j] >= i  
+ 确定边界
    - dp[0] = nums[0] > 0;
+ 计算顺序
    - 两次迭代，第一次迭代确定当前i位置，第二次迭代确定能跳到i位置的j

```java
public boolean canJump(int[] nums) {
        //1、确定状态 最终结果是需要确定数组下标最后一位是否可以到达
        //   确定dp[i] ，i为下标，数组类型为boolean true为可到达，false为不可到达
        boolean[] dp = new boolean[nums.length];
        //2 初始化状态
        dp[0] = true;
        //i确定当前位置
        for (int i = 1; i < nums.length; i++) {
            //j确定上一步的位置
            for (int j = 0; j < i; j++) {
                //3、状态转移方程
                //   dp[i] = dp[j] && num[j] >= i - j
                if(dp[j] && nums[j] >= i -j){
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[nums.length - 1];
    }
```

### 4、跳跃游戏2
> 与爬楼梯类似
>

[https://leetcode.cn/problems/jump-game-ii/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/jump-game-ii/description/?envType=study-plan-v2&envId=top-interview-150)

[跳跃游戏2-贪心算法](https://www.yuque.com/tuoyueerwu/ey40ze/gb53dnifmlpzgofn#ppqYW)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给定一个长度为</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">n</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">的</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">0 索引</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">整数数组</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">nums</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">。初始位置为</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">nums[0]</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">每个元素</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">nums[i]</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">表示从索引</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">i</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">向前跳转的最大长度。换句话说，如果你在</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">nums[i]</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">处，你可以跳转到任意</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">nums[i + j]</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">处:</font>
>
> + <font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">0 <= j <= nums[i]</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>
> + <font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">i + j < n</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">返回到达 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">nums[n - 1]</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 的最小跳跃次数。生成的测试用例可以到达 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">nums[n - 1]</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">。</font>
>

**步骤:**

+ 确定状态
    - 记录跳跃到最后一个位置的最少次数
    - dp[i] ,i表示下标，dp[i]表示跳转到i时最少的步数
+ 状态转移方程
    - dp[i] = min(dp[i],dp[j] + 1 if nums[j] + j >=i)
+ 初始化状态
    - dp[0] = 0
+ 计算顺序
    - 两次遍历 i确定当前下标，j确定i上一步的位置

```java
public int jump(int[] nums) {
        //动态规划
        //确定状态 dp[i] = 最少跳跃次数
        //状态转移 dp[i] = min (dp[i],dp[j]+ 1 if nums[j] + j >= i)
        //初始化状态
        int[] dp = new int[nums.length];
        Arrays.fill(dp, nums.length);
        dp[0] = 0;
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] + j >= i){
                    dp[i] = Math.min(dp[i],dp[j] + 1);
                }
            }
        }
        return dp[nums.length - 1];
    }
```

### 5、爬楼梯
[https://leetcode.cn/problems/climbing-stairs/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/climbing-stairs/description/?envType=study-plan-v2&envId=top-interview-150)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">假设你正在爬楼梯。需要</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">n</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 阶你才能到达楼顶。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">每次你可以爬 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">1</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 或 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">2</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</font>
>

**步骤:**

+ 确定状态
    - 记录跳到最后一阶的次数
    - dp[i] ，i 是台阶层数，dp[i] 是跳到第i层的不同跳法数
+ 状态转移
    - dp[i] = dp[i - 1] + dp[i - 2]
+ 初始化
    - 一次遍历
    - dp[1] = 1,dp[2] = 2

```java
class Solution {
    public int climbStairs(int n) {
        //
        if(n <= 2){
            return n;
        }
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3;i <= n;i++){
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

### 6、偷盗
[https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&envId=top-interview-150)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给定一个代表每个房屋存放金额的非负整数数组，计算你</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 不触动警报装置的情况下 </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，一夜之内能够偷窃到的最高金额。</font>
>

**步骤:**

+ 确定状态
    - 一夜之间能偷盗的最高金额，相邻的房子不能进行偷盗
    - dp[i] 偷到第i个房子所能获取的最大金额
+ 状态转移
    - dp[i] = max(dp[i - 2] + nums[i],dp[i - 1]) 
    - 当前位置的偷盗分两种情况
        * 如果偷到了当前位置的金额，那么当前位置表示为 dp[i - 2] + nums[i] ，i-2位置能拿到的最大金额 加上当前位置的金额
        * 如果偷盗上一个位置时，直接是dp[i - 1]
+ 初始化
    - dp[0] = nums[0];
    - dp[1] = max(nums[0],nums[1])

```java
class Solution {
    public int rob(int[] nums) {
        //动态规划
        //获取能偷窃的最高金额，不可偷相邻的房屋
        //确定状态 dp[i] 偷盗到第i家的最大金额
        //状态转移 
        //dp[i] = Math.max(dp[i - 2] + nums[i],dp[i - 1])
        if(nums.length == 1){
            return nums[0];
        }
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0],nums[1]);
        for(int i = 2;i < nums.length;i++){
            dp[i] = Math.max(dp[i - 2] + nums[i],dp[i - 1]);
        }
        return dp[nums.length - 1];
    }
}
```

### 7、单词拆分
[https://leetcode.cn/problems/word-break/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/word-break/?envType=study-plan-v2&envId=top-interview-150)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给你一个字符串 </font><font style="color:rgba(38, 38, 38, 0.75);">s</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 和一个字符串列表 </font><font style="color:rgba(38, 38, 38, 0.75);">wordDict</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 </font><font style="color:rgba(38, 38, 38, 0.75);">s</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 则返回 </font><font style="color:rgba(38, 38, 38, 0.75);">true</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">。</font>
>

**步骤:**

+ 确定状态
    - 字符串s中的单词是否都存在于字典wordDict中
    - dp[i]  表示i位置之前字符构成的单词存在于字典中。
+ 状态转移
    - dp[i] = = dp[j] && check (s[j,....,i-1]) ;
    - 当前i位置于前一个位置j之间构成的字符，判断是否存在于字典中，并且j位置之前的字符必须要存在字典中
+ 初始状态
    - 两层循环，外层循环控制字符串末值位置，内存循环控制字符串初始值位置



```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] dp = new boolean[s.length() + 1];
        //空字符串合法
        dp[0] = true;
        for(int i = 1;i <= s.length();i++){
            for(int j = 0;j < i;j++){
                if(dp[j] && wordDict.contains(s.substring(j,i))){
                    dp[i] = true;
                }
            }
        }
        return dp[s.length()];
    }
}
```

**记忆化搜索**

```java
public class WordBreak {
    int[] memo; // 用于记录中间结果的数组

    public boolean wordBreak(String s, List<String> wordDict) {
        memo = new int[s.length()]; // 初始化memo数组，长度为字符串s的长度
        Arrays.fill(memo, -1); // 将memo数组初始化为-1，表示尚未计算
        return dp(s, 0, wordDict); // 调用dp方法进行动态规划计算
    }

    private boolean dp(String s, int i, List<String> wordDict) {
        if (i >= s.length()) { // 如果当前位置i超过字符串长度，说明已经匹配完毕，返回true
            return true;
        }
        if (memo[i] != -1) { // 如果memo[i]已经计算过，直接返回对应结果
            return memo[i] == 1;
        }
        for (String string : wordDict) { // 遍历单词字典
            if (s.startsWith(string, i) && dp(s, i + string.length(), wordDict)) { // 如果能在当前位置匹配上单词，并且剩余部分也可以成功拆分
                memo[i] = 1; // 记录中间结果为1，表示可以成功拆分
                return true;
            }
        }
        memo[i] = 0; // 如果遍历完所有单词后仍然无法成功拆分，记录中间结果为0，表示无法拆分
        return false;
    }

    public static void main(String[] args) {
        WordBreak wordBreak = new WordBreak();
        List<String> wordDict = Arrays.asList("apple", "pen");
        System.out.println(wordBreak.wordBreak("applepenapple", wordDict)); // 输出：true
    }
}
```

### 8、零钱兑换
[https://leetcode.cn/problems/coin-change/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/coin-change/description/?envType=study-plan-v2&envId=top-interview-150)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给你一个整数数组</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">coins</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，表示不同面额的硬币；以及一个整数</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">amount</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，表示总金额。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">计算并返回可以凑成总金额所需的</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">最少的硬币个数</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">。如果没有任何一种硬币组合能组成总金额，返回 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">-1</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">你可以认为每种硬币的数量是无限的。</font>
>



**步骤:**

+ 确定状态
    - 给定的金额能组成，并且所需的硬币个数是最少
    - dp[i] 表示所需组成金额i所需的硬币个数，其中不能组成表示-1
+ 状态转移
    - dp[i] = min(dp[i - nums.for])
+ 初始化状态
    - 外层循环控制金额，内层循环控制硬币面额
    - dp[0] = 0

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        // 初始化一个数组，用于存储每个金额的最小硬币数
        int[] dp = new int[amount + 1];
        
        // 将所有金额初始化为一个较大的数，表示无法达到
        for (int i = 1; i <= amount; i++) {
            dp[i] = Integer.MAX_VALUE; 
        }

        // dp[0] = 0，因为金额为0时不需要任何硬币
        dp[0] = 0;

        // 计算每个金额所需的最小硬币数
        for (int coin : coins) {
            for (int i = coin; i <= amount; i++) {
                // 如果当前金额 i 大于或等于当前硬币面额
                // 更新 dp[i] 为最小值
                if (dp[i - coin] != Integer.MAX_VALUE) {
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }

        // 如果 dp[amount] 仍然是最大值，返回 -1 表示无法凑成该金额
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }
}
```

**记忆化搜索**

```java
public class Solution {
    public int coinChange(int[] coins, int amount) {
        if (amount < 1) {
            return 0;
        }
        return coinChange(coins, amount, new int[amount]);
    }

    private int coinChange(int[] coins, int rem, int[] count) {
        if (rem < 0) {
            return -1;
        }
        if (rem == 0) {
            return 0;
        }
        if (count[rem - 1] != 0) {
            return count[rem - 1];
        }
        int min = Integer.MAX_VALUE;
        for (int coin : coins) {
            int res = coinChange(coins, rem - coin, count);
            if (res >= 0 && res < min) {
                min = 1 + res;
            }
        }
        count[rem - 1] = (min == Integer.MAX_VALUE) ? -1 : min;
        return count[rem - 1];
    }
}
```

### 9、最长递增子序列
[https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&envId=top-interview-150)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给你一个整数数组</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">nums</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，找到其中最长严格递增子序列的长度。</font>
>
> **<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">子序列 </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，</font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">[3,6,2,7]</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 是数组 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">[0,3,1,6,2,2,7]</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 的</font><font style="background-color:rgb(240, 240, 240);">子序列</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">。</font>
>

**步骤：**

+ 确定状态
    - 获取数组的最长子序列
    - dp[i] 表示在i位置之前存在最长序列的长度
+ 状态转移
    - dp[i] = if(nums[i] > nums[j])  max ( dp[ j]) + 1
+ 初始化状态
    - 外层循环控制i，内层循环控制i之前的最长序列下标
    - dp[0] = 1;

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        // 如果数组长度为1，直接返回1
        if (nums.length == 1) {
            return 1;
        }
        
        int maxLength = 1; // 记录最长递增子序列的长度，默认为1
        int[] dp = new int[nums.length]; // 创建一个与原数组等长的数组dp，用于记录以nums[i]结尾的最长递增子序列的长度
        dp[0] = 1; // 初始化dp数组，第一个元素的最长递增子序列长度为1
        
        for (int i = 1; i < nums.length; i++) { // 遍历原数组
            int currMax = 1; // 当前位置的最长递增子序列长度，默认为1
            
            // 在nums[0:i-1]范围内查找比nums[i]小的元素，并更新当前最长递增子序列长度
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    currMax = Math.max(currMax, dp[j] + 1); // 如果找到比nums[i]小的元素，则更新当前最长递增子序列长度
                }
            }
            
            dp[i] = currMax; // 更新以nums[i]结尾的最长递增子序列的长度
            
            maxLength = Math.max(maxLength, dp[i]); // 更新整个数组的最长递增子序列长度
        }
        
        return maxLength; // 返回最长递增子序列的长度
    }
}
```

## 多维
### 1、三角形最小路径和
[https://leetcode.cn/problems/triangle/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/triangle/description/?envType=study-plan-v2&envId=top-interview-150)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给定一个三角形</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">triangle</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，找出自顶向下的最小路径和。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">每一步只能移动到下一行中相邻的结点上。</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">相邻的结点 </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">在这里指的是 </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">下标</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 与 </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">上一层结点下标</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 相同或者等于 </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">上一层结点下标 + 1</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 的两个结点。也就是说，如果正位于当前行的下标 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">i</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> ，那么下一步可以移动到下一行的下标 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">i</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 或 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">i + 1</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 。</font>
>

**步骤：**

+ 确定状态
    - 找出自顶向下的最小路径和，每一步只能移动到下一行中相邻的结点（指下标和上一层结点相同或者上一层结点 + 1）
    - dp[i][j] 表示i行j列到顶端的最小路径
+ 状态转移
    - dp[i][j] = min(dp[i - 1][j],dp([i -1][j - 1]) + nums[i][j]
+ 初始化状态
    - dp[0][0] = nums[0][0]
    - 先序遍历三角形节点，记录根节点往下的最小路径

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();
        int[][] dp = new int[n][n];
        dp[0][0] = triangle.get(0).get(0);
        for(int i = 1;i < n;i++){
            //最左边界的路径记录
            dp[i][0] = dp[i - 1][0] + triangle.get(i).get(0);
            for(int j = 1;j < i;j++){
                //状态转移
                dp[i][j] = Math.min(dp[i - 1][j],dp[i - 1][j - 1]) + triangle.get(i).get(j);
            }
            //最右边界的路径记录
            dp[i][i] = dp[i - 1][i - 1] + triangle.get(i).get(i);
        }
        int minCount = dp[n - 1][0];
        for(int i = 1;i < n;i++){
            //获取最后一行的最小路径
            minCount = Math.min(dp[n-1][i],minCount);
        }
        return minCount;
    }
}
```

**翻转数组：**

> 优化空间，将多维dp数组降维
>

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();
        //每一层的最小路径至于它上一层有关，所以通过一维覆盖的形式去存储
        int[] dp = new int[n];
        dp[0] = triangle.get(0).get(0);
        for (int i = 1; i < n; i++) {
            //倒序存储，数组后面的值先覆盖
            dp[i] = dp[i - 1] + triangle.get(i).get(i);
            for (int j = i - 1; j > 0; j--) {
                //状态转移
                dp[j] = Math.min(dp[j], dp[j - 1]) + triangle.get(i).get(j);
            }
            dp[0] = dp[0] + triangle.get(i).get(0);
        }
        int minCount = dp[0];
        for (int i = 1; i < n; i++) {
            //获取数组最小值作为最小路径
            minCount = Math.min(dp[i], minCount);
        }
        return minCount;
    }
}
```

### 2、最小路径和
[https://leetcode.cn/problems/minimum-path-sum/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/minimum-path-sum/description/?envType=study-plan-v2&envId=top-interview-150)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给定一个包含非负整数的</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>_<font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">m</font>_<font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);"> x </font>_<font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">n</font>_<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 网格 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">grid</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</font>
>
> **<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">说明：</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">每次只能向下或者向右移动一步。</font>
>



**步骤**

+ 确定状态
    - 从左上角走到右下角的数字总和为最小
    - dp[i][j] ,表示从dp[0][0]到第i行第j列的最小路径
+ 状态转移
    - when i == 0 && j != 0  dp[i][j] = dp[i][j - 1] +  nums[i][j]
    - when i != 0 && j == 0  dp[i][j] = dp[i - 1][j] + nums[i][j]
    - dp[i][j] = min(dp[i - 1][j],dp[i][j + 1]) + nums[i][j]
+ 初始化状态
    - dp[0][0] = nums[0][0]

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int rows = grid.length;
        int cols = grid[0].length;
        int[][] dp = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // 第一行单独计算
                if (i == 0 && j == 0) {
                    dp[0][0] = grid[0][0];
                } else if (i == 0 && j != 0) {
                    dp[i][j] = dp[i][j - 1] + grid[i][j];
                } else if (j == 0 && i != 0) {
                    dp[i][j] = dp[i - 1][j] + grid[i][j];
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
                }
            }
        }
        return dp[rows - 1][cols - 1];
    }
}
```

### 3、不同路径
[https://leetcode.cn/problems/unique-paths-ii/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/unique-paths-ii/description/?envType=study-plan-v2&envId=top-interview-150)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">一个机器人位于一个 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">m x n</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 网格的左上角 （起始点在下图中标记为 “Start” ）。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">网格中的障碍物和空位置分别用 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">1</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 和 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">0</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 来表示。</font>
>

**步骤:**

+ 确定状态
    - 从左下角移动到右下角，避开障碍物的同时，存在多少种路径
    - dp[i][j],移动到第i行第j列的位置存在多少种路径
+ 状态转移
    - when i == 0 && j != 0 && nums[i][j] != 1  dp[i][j] = dp[i - 1][j]
    - when j == 0 && i != 0 && nums[i][j] != 1 dp[i][j] = dp[i][j - 1] 
    - nums[i][j] != 1   dp[i][j] = dp[i - 1][j]  == 1 ? 0  : dp[i - 1][j]+ dp[i][j - 1]  ==1 ? 0 : dp[i][j - 1]
+ 初始化状态
    - dp[0][0] = 1

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int rows = obstacleGrid.length;
        int cols = obstacleGrid[0].length;
        if(obstacleGrid[rows - 1][cols - 1] == 1 || obstacleGrid[0][0] == 1){
            return 0;
        }
        int[][] dp = new int[rows][cols];
        dp[0][0] = 1;
        //初始化第一列
        for (int i = 1; i < rows; i++) {
            dp[i][0] = obstacleGrid[i][0] != 1 ? dp[i - 1][0] : 0;
        }
        //初始化第一行
        for (int i = 1; i < cols; i++) {
            dp[0][i] = obstacleGrid[0][i] != 1 ? dp[0][i - 1] : 0;
        }
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < cols; j++) {
                //当前障碍物处理
                if (obstacleGrid[i][j] == 1) {
                    dp[i][j] = 0;
                } else {
                    //状态转移
                    dp[i][j] = (obstacleGrid[i - 1][j] != 1 ? dp[i - 1][j]
                            : 0) + (obstacleGrid[i][j - 1] != 1 ? dp[i][j - 1] : 0);
                }
            }
        }
        return dp[rows - 1][cols - 1];
    }
}
```

问题分析：

+ （i,j）位置只能移动到(i - 1,j)或者(i,j - 1)位置，这说明转移是无后效性的，f(i,j) 与f(i`,j`) （i``> i,j` > j）无关
+ 动态规划一般分成两种，一种是最优求解，常见的有背包问题，另一种就是计数求解。这两种题目都存在一个递推性质
    - 这种递推性质可以称作最优子结构，即当前问题的最优解取决于子结构的最优解，当前问题的方案数取决于子结构的方案数，这类问题都可以通过动态规划去解决。



### 4、最长回文子串
[https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=study-plan-v2&envId=top-interview-150)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给你一个字符串 </font><font style="color:rgba(38, 38, 38, 0.75);">s</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，找到 </font><font style="color:rgba(38, 38, 38, 0.75);">s</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 中最长的回文子串(</font>果字符串向前和向后读都相同，则它满足 **回文性**。<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">). </font>
>



**步骤：**

+ 确定状态
    - 确定字符串中的最长回文子串
    - dp[i][j] 表示从i开始到j个字符组成的是回文子串 布尔类型的数组
+ 状态转移
    - dp[i][j] = dp[i + 1][j - 1] && nums[i] == nums[j]
+ 初始化状态
    - 所有长度为1 的子串都初始化成true，dp[i][i] = true



```java
class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        if (n < 2) {
            return s;
        }

        char[] charArray = s.toCharArray();
        boolean[][] dp = new boolean[n][n];
        int start = 0; // 记录最长回文子串的起始索引
        int maxLength = 1; // 记录最长回文子串的长度

        // 初始化所有长度为1的子串为回文串
        for (int i = 0; i < n; i++) {
            dp[i][i] = true;
        }

        // 动态规划，从长度较小的子串向长度较大的子串逐步扩展
        for (int length = 2; length <= n; length++) {
            for (int i = 0; i <= n - length; i++) {
                int j = i + length - 1; // 子串的结束索引
                if (charArray[i] == charArray[j]) {
                    if (length == 2 || dp[i + 1][j - 1]) {
                        dp[i][j] = true; // 更新当前子串是否为回文串
                        if (length > maxLength) {
                            start = i; // 更新最长回文子串的起始索引
                            maxLength = length; // 更新最长回文子串的长度
                        }
                    }
                }
            }
        }

        return s.substring(start, start + maxLength); // 返回最长回文子串
    }
}
```

### 5、交错字符串
[https://leetcode.cn/problems/interleaving-string/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/interleaving-string/description/?envType=study-plan-v2&envId=top-interview-150)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给定三个字符串 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">s1</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">、</font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">s2</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">、</font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">s3</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，请你帮忙验证 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">s3</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 是否是由 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">s1</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 和 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">s2</font>_<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>_**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">交错</font>****<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">组成的。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">两个字符串 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">s</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 和 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">t</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">交错</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 的定义与过程如下，其中每个字符串都会被分割成若干 </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">非空</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="background-color:rgb(240, 240, 240);">子字符串</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">：</font>
>
> ![](https://cdn.nlark.com/yuque/0/2024/png/22648511/1716882260883-a9288459-466d-482b-9b1e-6cc45f242c6d.png)
>

**步骤：**

+ 确定状态
    - 字符串s3是由s1和s2交错组成
    - boolean类型dp[i][j] 表示s1的前i个元素和s2的前j个元素是否可以交错组成s3的前i+j个元素
+ 状态转移
    - 判断i+j位置的元素是否在s1上
    - dp[i][j] = dp[i][j] || (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1))
    - 判断i+j位置上的元素是否在s2上
    - dp[i][j] = dp[i][j] || (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1))
+ 初始化状态 
    - dp[0][0]  = true 空字符串时可以交错组成



```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int n = s1.length();
        int m = s2.length();
        int k = s3.length();
        //如果长度不相等直接返回
        if(n + m != k){
            return false;
        }
        boolean[][] dp = new boolean[n + 1][m + 1];
        //0位置表示空字符串 所以数组的长度需要加1
        dp[0][0] = true;
        char[] charArray = s3.toCharArray();
        for(int i = 0;i <= n;i++){
            for(int j = 0;j <= m;j++){
                int index = i + j - 1;
                //因为从index = 1开始遍历 所以需要判断i和j > 0的情况
                if(i > 0) dp[i][j] = dp[i][j] || (dp[i - 1][j] && s1.charAt(i - 1) == charArray[index]);
                if(j > 0) dp[i][j] = dp[i][j] || (dp[i][j - 1] && s2.charAt(j - 1) == charArray[index]);
            }
        }
        return dp[n][m];
    }
}
```

**翻转数组:**

> 空间优化，将多维dp数组降维度
>

```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int n = s1.length();
        int m = s2.length();
        int k = s3.length();
        if(n + m != k){
            return false;
        }
        char[] s1CharArr = s1.toCharArray();
        char[] s2CharArr = s2.toCharArray();
        char[] s3CharArr = s3.toCharArray();
        boolean[] dp = new boolean[m + 1];
        dp[0] = true;
        //因为本行的数据只与上左有关，所以通过一维的形式存储上左的数据更新的时候不造成数据干扰就行
        for(int i = 0;i <= n;i++){
            for(int j = 0;j <= m;j++){
                int index = i + j - 1;
                //原来 i需要 上一行 (i - 1 ,j)的值进行判断，现在只需要 (i,j)进行判断 即dp[j]
                if(i > 0) dp[j] = dp[j] && s1CharArr[i - 1] == s3CharArr[index];
                //原j 需要 上一列 (i,j - 1)的值进行判断，现在也是，即dp[j - 1]
                if(j > 0) dp[j] = dp[j] || dp[j - 1] && s2CharArr[j - 1] == s3CharArr[index];
            }
        }
        return dp[m];
    }
}
```



### 6、编辑距离
[https://leetcode.cn/problems/edit-distance/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/edit-distance/description/?envType=study-plan-v2&envId=top-interview-150)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给你两个单词 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">word1</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">和 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">word2</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>_<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">请返回将 </font>__<font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">word1</font>__<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 转换成 </font>__<font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">word2</font>__<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>__<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">所使用的最少操作数</font>_<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">你可以对一个单词进行如下三种操作：</font>
>
> + <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">插入一个字符</font>
> + <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">删除一个字符</font>
> + <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">替换一个字符</font>
>

**步骤:**

+ 确定状态
    - 将字符word1转成字符word2需要最少的操作数，三种操作方式，将字符增加，减少或者替换，其中word1删除相当于在word2中插入数据
        * 操作1：word1中插入字符
        * 操作2：word2中插入字符
        * 操作3：替换一个字符
    - dp[i][j] 表示 字符word1前i个字符转成字符word2前j个字符最少需要多少步
+ 状态转移
    - 其中dp[i][j]可以由三种状态转移而成，分别是
        * 操作1：dp[i - 1][j] 往word1尾部插入一个字符
        * 操作2：dp[i][j - 1] 往word2尾部插入一个字符
        * 操作3：dp[i - 1][j - 1] 往word2或者word1尾部修改一个字符
        * dp[i][j] = min(dp[i - 1][j]],dp[i][j - 1], dp[i - 1][j - 1]) + 1      word1与word2尾部字符不同
        * dp[i][j] = min(dp[i - 1][j]],dp[i][j - 1], dp[i - 1][j - 1] - 1) + 1      word1与word2尾部字符相同(所以操作3不需要修改字符)
+ 初始化状态
    - 空字符和普通字符之间的距离是普通字符的长度
    - dp[i][0] = i
    - dp[j][0] = j

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int n = word1.length();
        int m = word2.length();
        if( n == 0){
            return m;
        }
        if(m == 0){
            return n;
        }
        int[][] dp = new int[n + 1][m + 1];
        //空字符距离初始化
        for(int i = 0;i <= n;i++){
            dp[i][0] = i;
        }
        for(int j = 0;j <= m;j++){
            dp[0][j] = j;
        }

        for(int i = 1;i <= n;i++){
            for(int j = 1;j <= m; j++){
                int min1 = dp[i - 1][j];
                int min2 = dp[i][j - 1];
                int min3 = dp[i - 1][j - 1];
                //如果当前字符相同
                if(word1.charAt(i - 1) == word2.charAt(j - 1)){
                    //则缺少的需要进行插入，不缺的则不动
                    dp[i][j] = Math.min(min1,Math.min(min2,min3 - 1)) + 1;
                }else{
                    //不同则都需要进行操作
                    dp[i][j] = Math.min(min1,Math.min(min2,min3)) + 1;
                }
            }
        }
        return dp[n][m];
    }
}
```

### 7、买股票的最佳时机
[https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/?envType=study-plan-v2&envId=top-interview-150)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给定一个数组，它的第</font>_<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>_<font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">i</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">个元素是一支给定的股票在第</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">i</font>_<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>_<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">天的价格。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">设计一个算法来计算你所能获取的最大利润。你最多可以完成 </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">两笔 </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">交易。</font>
>
> **<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">注意：</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</font>
>

**步骤：**

+ 确定状态
    - 计算交易获得的最大利润，最多进行两次交易
    - 很难直接通过一个状态去获取最大利润，所以进行状态拆解，我们可以得出一天内存在四个状态
        * 当前天之前，只进行了一次买入的最大利润 buy1[i]
        * 当前天之前，只进行了一次卖出的最大利润 sell1[i]
        * 当前天之前，进行了两次买入的最大利润 buy2[i]
        * 当前天之前，进行了两次的卖出的最大利润 sell2[i]
    - 因为这四种状态存在一个递推关系，我们需要的是最后一个，所以需要通过前面三个状态进行递推转换
+ 状态转移
    - buy1[i] = max(buy[i - 1],-price[i]);  第一次买入的最大利润只于在哪次买入有关
    - sell1[i] = max(sell1[i - 1],buy[i - 1] + price[i]) 第一次卖出的最大利润，在第一次卖出最大利润的基础上进行计算
    - buy2[i] = max(buy2[i - 1],sell1[i - 1] - price[i]]) 第二次买入的最大利润，在第一次卖出的基础上进行计算
    - sell2[i] = max(sell2[i - 1],buy2[i  - 1] + price[i]) 第二次卖出的最大利润，在第二次买入的基础上进行计算
+ 初始化状态
    - buy1[0] = -price[0]
    - sell1[0] = 0
    - buy2[0] = -price[0] 
    - sell2[0] = 0

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[] buy1 = new int[n];
        int[] sale1 = new int[n];
        int[] buy2 = new int[n];
        int[] sale2 = new int[n];
        buy1[0] = -prices[0];
        sale1[0] = 0;
        buy2[0] = -prices[0];
        sale2[0] = 0;
        for(int i = 1;i < n;i++){
            buy1[i] = Math.max(buy1[i - 1],-prices[i]);
            sale1[i] = Math.max(sale1[i - 1],buy1[i - 1] + prices[i]);
            buy2[i]= Math.max(buy2[i - 1],sale1[i - 1] - prices[i]);
            sale2[i] = Math.max(sale2[i - 1],buy2[i - 1] + prices[i]);
            //System.out.println(buy1 + " " + sale1 + " " + buy2 + " " + sale2);
        }
        return sale2[n - 1];
    }
}
```

**翻转数组：**

> 空间优化：通过状态转移方程很明显能看出 第i天的状态只与第i - 1天有关，所以通过一维的形式去存储i和i- 1天的结果
>

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int buy1 = -prices[0];
        int sale1 = 0;
        int buy2 = -prices[0];
        int sale2 = 0;
        for(int i = 1;i < n;i++){
            buy1 = Math.max(buy1,-prices[i]);
            sale1 = Math.max(sale1,buy1 + prices[i]);
            buy2= Math.max(buy2,sale1 - prices[i]);
            sale2 = Math.max(sale2,buy2 + prices[i]);
            //System.out.println(buy1 + " " + sale1 + " " + buy2 + " " + sale2);
        }
        return sale2;
    }
}
```

### 8、买股票的最佳时机
[https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/?envType=study-plan-v2&envId=top-interview-150)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给你一个整数数组 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">prices</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">和一个整数</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">k</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，其中</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">prices[i]</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">是某支给定的股票在第</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">i</font>_<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>_<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">天的价格。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">设计一个算法来计算你所能获取的最大利润。你最多可以完成</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">k</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">笔交易。也就是说，你最多可以买</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">k</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">次，卖</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">k</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">次。</font>
>
> **<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">注意：</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</font>
>

**步骤:**

+ 确定状态
    - 可以卖k次，计算最大利润，需要注意如果k>n/2时，即可以最大买卖，可以通过贪心去计算
    - 两个状态，buy和sell
    - buy[i] 表示在当前位置买i次产生的最大利润
    - sell[i] 表示在当前位置卖了i次产生的最大利润
    - 以上是在上一题的基础上进行空间优化
+ 状态转移
    - buy[i] = max(buy[i],sell[i - 1] - price[i]);
    - sell[i] = max(sell[i],buy[i - 1] + price[i]);
+ 初始化状态
    - Arrays.fill(buy, Integer.MIN_VALUE); 
    - 将buy数组初始化为负无穷，用来保证初始值对后续状态更替不产生影响，因为在取最大值的过程中，buy数组产生负数，而数组的初始值是0，很容易造成影响

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        int n = prices.length;
        // 如果k> n/2时可以通过贪心算法直接进行计算
        if (k > n / 2) {
            int maxProfit = 0;
            for (int i = 1; i < n; i++) {
                if (prices[i] > prices[i - 1]) {
                    maxProfit += (prices[i] - prices[i - 1]);
                }
            }
            return maxProfit;
        }
        int[] buy = new int[k];
        int[] sell = new int[k];
        Arrays.fill(buy, Integer.MIN_VALUE); // 将buy数组初始化为负无穷
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < k; j++) {
                buy[j] = Math.max(buy[j], (j == 0 ? 0 : sell[j - 1]) - prices[i]);
                sell[j] = Math.max(sell[j], buy[j] + prices[i]);
            }
        }
        return sell[k - 1];
    }
}

```



### 9、最大正方形
[https://leetcode.cn/problems/maximal-square/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/maximal-square/description/?envType=study-plan-v2&envId=top-interview-150)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">在一个由 </font><font style="color:rgba(38, 38, 38, 0.75);">'0'</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 和 </font><font style="color:rgba(38, 38, 38, 0.75);">'1'</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 组成的二维矩阵内，找到只包含 </font><font style="color:rgba(38, 38, 38, 0.75);">'1'</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 的最大正方形，并返回其面积。</font>
>

**步骤：**

+ 确定状态
    - 在整个二维矩阵内找到只包含1的最大正方形，递推最小子结构，即记录每个位置所能组成的最大正方形的面积
    - dp[i][j] 以坐标(i,j)为右下角组成的最大正方形的面积
+ 状态转移
    - dp[i][j] = nums[i][j] == 1 ？ min(dp[i][j - 1],dp[i - 1][j],dp[i - 1][j - 1]) + 1 ： 0
    - i,j位置的最大正方形面积只与该位置的上方，左上方，左方的最大正方形面积有关
+ 初始化状态
    - 当i为0或者j为0时，最大正方形面积必然为1
    - dp[i][j] = 1 



```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        int[][] dp = new int[rows][cols];
        //初始化边界
        int maxValue = 0;
        for(int i = 0 ;i < rows;i++){
            if(matrix[i][0] == '1'){
                dp[i][0] = 1;
                maxValue = 1;
            }
        }
        for(int i = 0 ;i < cols;i++){
            if(matrix[0][i] == '1'){
                dp[0][i] = 1;
                maxValue = 1;
            }
        }
        //System.out.println(Arrays.deepToString(dp));
        for(int i = 1;i < rows;i++){
            for(int j = 1;j < cols;j++){
                if(matrix[i][j] == '1'){
                    //状态转移
                    dp[i][j] = Math.min(dp[i- 1][j] ,Math.min(dp[i][j- 1],dp[i - 1][j - 1])) + 1;
                    //更新最大面积
                    maxValue = Math.max(maxValue,dp[i][j] * dp[i][j]);
                }
            }
        }

        //System.out.println(Arrays.deepToString(dp));
        return maxValue;
    }
}
```



