+++
date = "2025-09-11T14:00:54"
title = "递归"
tags = ["算法"]
+++
# 一、定义
> 递归是一种通过调用自身来解决问题的编程技巧或算法。
>
> 在递归的过程中将问题分解为规模较小的子问题，并通过调用自身来解决这些子问题，最终将所有子问题的结果合并以解决原始问题。
>

+ Master公式
    - 是一种解决递归算法时间复杂度的公式，用于快速定位递归算法的时间复杂度，尤其适用分治算法中的递归问题。
    - 一系列符合子问题等规模问题才可以通过Master公式来求时间复杂度
    - T(N)	=  a * T(n/b) + f(n)
        * T(N) 表示母问题时间复杂度
        * a 表示调用递归方法的次数
        * n/b  表示问题缩小比例
        * T(n/b) 表示递归子问题的时间复杂度
        * f(n)表示除递归之外的时间复杂度
        * <font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">Master公式一般用于分析分治算法、递归算法、递归关系式等场景，特别是在算法设计和分析中有递归结构的问题中，可以帮助我们快速了解算法的时间复杂度。</font>
        * <font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">Master公式通常与递归树（Recurrence Tree）一起使用，递归树可以将递归算法的执行过程可视化，进而辅助使用Master公式求解递归算法的时间复杂度。</font>
    - <font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">logb a < d   ====> O(N^d)</font>
    - <font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">logb a > b   ====> O(N ^ logb a)</font>
    - <font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">logb a == b ====> O(N ^d * logN)</font>
+ 汉诺塔问题
+ 生成全子序列
+ 生成全排序
+ 对数器方法采用的递归

## 回溯
### 定义
        * 回溯法也可以叫回溯搜素法，它是一种搜素的方式，在二叉树或者树系列中频繁出现。
        * 回溯是递归的副产品，存在递归的地方就有可能会有回溯。
        * 回溯算法的性能一般，其本质就是穷举，可以通过一些剪枝操作提高效率但是也改变不了穷举的本质。

### 解决的问题
+ **搜索问题**：这类问题的目标是找到满足特定条件的解决方案
    - 排列问题：N个数按一定的规则全排列，有几种排列方式
    - 组合问题：N个数里面按一定的规则找出k个数的集合
    - 子集和问题：一个N个数的集合中有多少符合条件的子集
    - 汉诺塔问题：给定三根柱子和一系列大小不同的圆盘，要求将所有的圆盘从一根柱子移动到另一根柱子，每次只能移动一个圆盘，且不能将大圆盘放在小圆盘上
    - 切割问题：一个字符串按一定的规则有几种切割方式
+ **约束满足问题 **：这类问题的目标是找到所有满足约束条件的解
    - n皇后：在N*N的棋盘上放置N个皇后，使得它们互不攻击
    - 数独：在9*9的网格中填入1-9，使得每行，每列和每个3*3子网格的数字不重复
    - 图着色问题：给定一个无向图，用最少的颜色给图的每个顶点着色，使得相邻顶点颜色不同
+ **组合优化问题**：这类问题的目标是在一个组合空间中找到满足某些条件的最优解
    - 0-1背包问题：给定一组物品和一个背包，每个物品有一定的价值和重量，要求在背包容量限制内，选择物品使得总价值最大。
    - 旅行商问题：在一个图中，从一个点触发访问所有其他点恰好一次后返回起点，求最短路径。
    - 最大图问题：给定一个无向图，找到最大的完全子图，即子图中的任意两个顶点之间都有边相连。
    - **注意**：对于很多组合优化问题，回溯不是最优解决方案。
        * 0-1背包问题：通常使用动态规划解决，以达到更高的事件效率。
        * 旅行商问题是一个著名的NP-Hard问题，常用的解法有遗传算法和蚁群算法等。
        * 最大团问题是图论中的一个经典问题，可用贪心算法等启发式算法来解决。

# 二、经典题解
## 通用模板
```java
void backtrack (State state,List<Choice> choices,List<State> res){
    //判断是否为解
    if(isSolution(state)){
        //记录解
        recordSolution(state,res);
        retrun;
    }

    //遍历所有选择
    for(Choice choice : choices){
        //剪枝:判断选择是否合法
        if(isValid(state,choice)){
            //尝试做出选择，更新状态
            makeChoice(state,choice);
            backtrack(state,choice,res);
            //回退;撤销选择，恢复到之前的状态
            undoChoice(state,choice);
        }
    }
}

```

## 1、全排列问题
全排列问题是一个回溯算法的典型应用。它的定义是在给定一个集合（如一个数组或字符串）的情况下，找出其中元素的所有可能的排列。

**示例数据**：

| 输入数组 | 输出数组 |
| --- | --- |
| [1,2] | [1,2],[2,1] |
| [1,2,3] | [1,2,3],[1,3,2],[2,1,3],[3,1,2],[3,2,1] |




**1、无相等元素情况**

> 输入一个整数数组，其中不包含重复元素，返回所有可能的排列。
>

**思路**

从回溯算法的角度看，我们可以把生成排列的过程想象成一系列选择的结果；

假设输入数组为[1,2,3],如果我们先选择1，再选择3,最后选择2，则获得排列[1,3,2]。回退表示撤销一个选择，之后继续尝试其他选择。

+ choose和state选择
    - chooses表示输入的数组，state表示当前状态（当前组合中数的集合），因为输入数组不重复，且每个数只允许选择一次，所以state中的元素表示唯一。
+ 剪枝
    - 为了实现每个元素只被选择一次，我们考虑引入一个boolean类型数组selected[i]，来记录数组是否被选择过。
    - 遍历选择列表choices时，跳过所有已被选择的节点，即剪枝。



```java
/**
     *  全排列递归回溯
     * @param nums 输入数组
     * @param state 临时记录
     * @param res 结果集
     * @param selected 临时记录中所选元素
     */
    static void backTrack(int[] nums,List<Integer> state,  List<List<Integer>> res,boolean[] selected){
        //判断是否为解
        if (state.size() == nums.length){
            //记录解 拷贝一份记录
            res.add(new ArrayList<>(state));
            return;
        }

        //遍历所有选择
        for (int i = 0; i < nums.length; i++) {
            if (selected[i]){
                continue;
            }
            int num = nums[i];
            state.add(num);
            selected[i] = true;
            backTrack(nums,state,res,selected);
            //回溯 移除最后添加的元素
            state.remove(state.size() - 1);
            selected[i] = false;
        }
    }
```

**2、存在相等元素**

> 通过一个Set来记录对应结果集选择的元素，让每次选择的重复元素进行剪枝，保证这次选择中相等的元素只被选择一次。
>

```java
/**
     *  全排列递归回溯 输入存在重复元素
     * @param nums 输入数组
     * @param state 临时记录
     * @param res 结果集
     * @param selected 临时记录中所选元素
     */
    static void backTrack2(int[] nums,List<Integer> state,  List<List<Integer>> res,boolean[] selected){
        //判断是否为解
        if (state.size() == nums.length){
            //记录解 拷贝一份记录
            res.add(new ArrayList<>(state));
            return;
        }

        Set<Integer> repeatNum = new HashSet<>();
        //遍历所有选择
        for (int i = 0; i < nums.length; i++) {
            int num = nums[i];
            if (selected[i] || repeatNum.contains(num)){
                continue;
            }
            state.add(num);
            repeatNum.add(num);
            selected[i] = true;
            backTrack2(nums,state,res,selected);
            //回溯 移除最后添加的元素
            state.remove(state.size() - 1);
            selected[i] = false;
        }
    }
```



## 2、子集合问题
> 给定一个集合，和一个目标值，返回符合条件合为目标值的子集合；
>

+ 思路
    - 1、可以看作是在全排列的基础上，通过目标值进行选择；
    - 2、因为元素可以重复选择，所以可以不用boolean来记录是否选择；
    - 3、因为需要排除元素相同顺序不同的集合，所以将集合排序，传入下次遍历的开始索引（限定遍历顺序，只能从前往后选择，且元素不重复）。

**无重复元素**

```java
/**
     * 无重复元素 子集合实现 （先行排序，然后通过传递遍历下标的形式去排除 重复子集合）
     * @param nums
     * @param tempRes
     * @param res
     * @param target
     */
    static void backTrack(int[] nums, List<Integer> tempRes, List<List<Integer>> res, int target,int index){
        //记录解
        if (target == 0){
            res.add(new ArrayList<>(tempRes));
            return;
        }

        for (int i = index; i < nums.length; i++) {
            int num = nums[i];
            //剪枝
            if (target - num < 0){
                continue;
            }
            tempRes.add(num);
            backTrack(nums,tempRes,res,target - num,i);
            //回溯
            tempRes.remove(tempRes.size() - 1);
        }
    }
```

**重复元素情况**

> 题目的变种，集合中每个元素只能被选择一次，但是集合中存在重复的元素。
>

+ 思考
    - 1、在无重复元素的基础上进行改造；每个元素只能被选择一次
        * 传入的下一个元素的下标只能是当前下标 + 1
    - 2、每次选择重复元素只能被选择一次
        * 输入集合排序之后，在进行遍历选择的时候，当前元素如果等于上一个元素则跳过



```java
 /**
     *  输入集合存在重复，且每个元素只被选择一次
     * @param nums
     * @param tempRes
     * @param res
     * @param target
     * @param index
     */
    static void backTrack2(int[] nums, List<Integer> tempRes, List<List<Integer>> res, int target,int index){
        //记录解
        if (target == 0){
            res.add(new ArrayList<>(tempRes));
            return;
        }
        int pre = 0;
        for (int i = index; i < nums.length; i++) {
            int num = nums[i];
            //剪枝
            if (target - num < 0 || pre == num){
                continue;
            }
            pre = num;
            tempRes.add(num);
            backTrack2(nums,tempRes,res,target - num,i + 1);
            //回溯
            tempRes.remove(tempRes.size() - 1);
        }
    }
```



## 3、n皇后问题
> 根据国际象棋规定，皇后可以对其所在行、列、斜线的棋子进行攻击，现在给你n个皇后和n*n大小的棋盘，找到所有皇后之间无法攻击的摆放方案。
>

<font style="color:rgb(29, 29, 32);">如图 13-15 所示，当</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">n</font><font style="color:rgb(29, 29, 32);">=</font><font style="color:rgb(29, 29, 32);">4</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">时，共可以找到两个解。从回溯算法的角度看，</font><font style="color:rgb(29, 29, 32);">n</font><font style="color:rgb(29, 29, 32);">×</font><font style="color:rgb(29, 29, 32);">n</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">大小的棋盘共有</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">n</font><font style="color:rgb(29, 29, 32);">2</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">个格子，给出了所有的选择</font><font style="color:rgb(29, 29, 32);"> </font>`choices`<font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">。在逐个放置皇后的过程中，棋盘状态在不断地变化，每个时刻的棋盘就是状态</font><font style="color:rgb(29, 29, 32);"> </font>`state`<font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">。</font>

![](https://cdn.nlark.com/yuque/0/2024/png/22648511/1729317621014-2847d888-1b01-41d0-a74e-189d7ef5270d.png)

<font style="color:rgb(29, 29, 32);">为了满足列约束，我们可以利用一个长度为</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">n</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">的布尔型数组</font><font style="color:rgb(29, 29, 32);"> </font>`cols`<font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">记录每一列是否有皇后。在每次决定放置前，我们通过</font><font style="color:rgb(29, 29, 32);"> </font>`cols`<font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">将已有皇后的列进行剪枝，并在回溯中动态更新</font><font style="color:rgb(29, 29, 32);"> </font>`cols`<font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">的状态。</font>

**<font style="color:rgb(29, 29, 32);">Tip</font>**

<font style="color:rgb(29, 29, 32);">请注意，矩阵的起点位于左上角，其中行索引从上到下增加，列索引从左到右增加。</font>

<font style="color:rgb(29, 29, 32);">那么，如何处理对角线约束呢？设棋盘中某个格子的行列索引为</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">(</font><font style="color:rgb(29, 29, 32);">r</font><font style="color:rgb(29, 29, 32);">o</font><font style="color:rgb(29, 29, 32);">w</font><font style="color:rgb(29, 29, 32);">,</font><font style="color:rgb(29, 29, 32);">c</font><font style="color:rgb(29, 29, 32);">o</font><font style="color:rgb(29, 29, 32);">l</font><font style="color:rgb(29, 29, 32);">)</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">，选定矩阵中的某条主对角线，我们发现该对角线上所有格子的行索引减列索引都相等，</font>**<font style="color:rgb(29, 29, 32);">即主对角线上所有格子的</font>****<font style="color:rgb(29, 29, 32);"> </font>****<font style="color:rgb(29, 29, 32);">r</font>****<font style="color:rgb(29, 29, 32);">o</font>****<font style="color:rgb(29, 29, 32);">w</font>****<font style="color:rgb(29, 29, 32);">−</font>****<font style="color:rgb(29, 29, 32);">c</font>****<font style="color:rgb(29, 29, 32);">o</font>****<font style="color:rgb(29, 29, 32);">l</font>****<font style="color:rgb(29, 29, 32);"> </font>****<font style="color:rgb(29, 29, 32);">为恒定值</font>**<font style="color:rgb(29, 29, 32);">。</font>

<font style="color:rgb(29, 29, 32);">也就是说，如果两个格子满足</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">r</font><font style="color:rgb(29, 29, 32);">o</font><font style="color:rgb(29, 29, 32);">w</font><font style="color:rgb(29, 29, 32);">1</font><font style="color:rgb(29, 29, 32);">−</font><font style="color:rgb(29, 29, 32);">c</font><font style="color:rgb(29, 29, 32);">o</font><font style="color:rgb(29, 29, 32);">l</font><font style="color:rgb(29, 29, 32);">1</font><font style="color:rgb(29, 29, 32);">=</font><font style="color:rgb(29, 29, 32);">r</font><font style="color:rgb(29, 29, 32);">o</font><font style="color:rgb(29, 29, 32);">w</font><font style="color:rgb(29, 29, 32);">2</font><font style="color:rgb(29, 29, 32);">−</font><font style="color:rgb(29, 29, 32);">c</font><font style="color:rgb(29, 29, 32);">o</font><font style="color:rgb(29, 29, 32);">l</font><font style="color:rgb(29, 29, 32);">2</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">，则它们一定处在同一条主对角线上。利用该规律，我们可以借助图 13-18 所示的数组</font><font style="color:rgb(29, 29, 32);"> </font>`diags1`<font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">记录每条主对角线上是否有皇后。</font>

<font style="color:rgb(29, 29, 32);">同理，</font>**<font style="color:rgb(29, 29, 32);">次对角线上的所有格子的</font>****<font style="color:rgb(29, 29, 32);"> </font>****<font style="color:rgb(29, 29, 32);">r</font>****<font style="color:rgb(29, 29, 32);">o</font>****<font style="color:rgb(29, 29, 32);">w</font>****<font style="color:rgb(29, 29, 32);">+</font>****<font style="color:rgb(29, 29, 32);">c</font>****<font style="color:rgb(29, 29, 32);">o</font>****<font style="color:rgb(29, 29, 32);">l</font>****<font style="color:rgb(29, 29, 32);"> </font>****<font style="color:rgb(29, 29, 32);">是恒定值</font>**<font style="color:rgb(29, 29, 32);">。我们同样也可以借助数组</font><font style="color:rgb(29, 29, 32);"> </font>`diags2`<font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">来处理次对角线约束。</font>

![](https://cdn.nlark.com/yuque/0/2024/png/22648511/1729332291714-d09382ba-c101-43a5-a16f-080472884bba.png)

<font style="color:rgb(29, 29, 32);">图 13-18   处理列约束和对角线约束</font>



+ 思路
    - 限制条件
        * 每行只能存在一个皇后
        * 每列只能存在一个皇后
        * 每个对角线只能存在一个皇后



```java
/**
     * N皇后问题
     * @param res
     * @param row 遍历的行数（由规则可知，每行只存在一个皇后，所以以行为固定参数进行遍历）
     * @param n 总行数(遍历到最后一行，记录符合条件的数据集)
     * @param temRes 临时数组，存储数据集
     * @param clos 列标记(标记被攻击的列)
     * @param dag1 正向对角线标记(标记被攻击的正向对角线) 对角线数量是 2*n - 1 该位置的对角线是 dag1 = row - clo + n - 1
     * @param dag2 反向对角线标记(标记被攻击的反向对角线) 正反向对角线数量相同，该位置对角线是 dag2 = row + clo；
     */
    static void backtrack(List<List<Integer>> res,int row,int n,List<Integer> temRes,boolean[] clos,boolean[] dag1,boolean[] dag2){
        if (row == n){
            res.add(new ArrayList<>(temRes));
        }

        for (int clo = 0; clo < n; clo++) {
            //剪枝 判断当前位置是否被皇后攻击
            if (clos[clo] || dag1[row - clo + n - 1] || dag2[row + clo]){
                continue;
            }

            temRes.add(clo);
            clos[clo] = dag1[row - clo + n - 1] = dag2[row + clo] = true;
            backtrack(res,row + 1,n,temRes,clos,dag1,dag2);
            //递归
            temRes.remove(temRes.size() - 1);
            //回溯
            clos[clo] = dag1[row - clo + n - 1] = dag2[row + clo] = false;
        }
    }
```

# 三、实例
## 1、普通递归
> 给一组数，求其中的最大数
>

```java
public int getMax(int[] arr){
    process(arr,0,arr.length() - 1);
}

public int process(int[] arr,int left,int right){
    if(left == right){
        return arr[left];
    }
    //通过位运算计算中间值有两个好处
    //1、有效避免了整数类型的溢出
    //2、在硬件层面来说位运算比除指令效率更高
    int mid = left + ((right - left) >> 1);
    int leftMax = process(arr,left,mid);
    int rightMax = process(arr,mid,left);
    return Matn.max(leftMax,rightMax);
}
```

> Master公式
>
> T(N) = 2 * T(n/2) + O(1)
>
> log2 2 == 1
>
> T(N) = O(N ^ logb a);
>

## 2、递归回溯剪枝
> 给定一个数组A{2,3,6,7}和一个数B，要求输出数组A中构成B的数，且数组A中的数可重复出现。
>
> 输出:{2,2,3},{7}
>

思路：

+ 排序和剪枝
    - 首先对数组A进行排序，这样可以在后续遍历的过程中方便进行剪枝处理，减少不必要的搜索。
+ 回溯算法
    - 使用回溯算法探索所有可能组合。
        * 回溯算法是一种递归的深度优先搜索方法，用于解决组合问题。
    - 维护一个当前组合集，递归添加数据， 回溯移除数据，直到组合的和等于目标数，或超过目标数（进行剪枝）
+ 回溯的过程
    - 通过下标选定最小的元素，往组合中添加，如果组合值和目标值的差值小于当前元素，则移除最后加入的元素，尝试下一个元素，直到所有可能的组合都被尝试完毕。



```java
public void main(String args[]){
    int[] a = new int[]{2,3,5,7};
    int b = 7;
    Arrays.sort(a);
    List<List<Integer>> resultList = new ArrayList<>();
    System.out.println();
}

public void combine(int[] a ,int b ,int index,List<Integer> currentList,List<List<Integer>> result){
    if(b == 0){
        //通过创建集合的方式去更改currentList的引用
        resultList.add(new ArrayList<>(currentList));
    }
    for(int i = index;i < a.length; i++){
        if(a[i] > b){
            //如果当前值超过b，则说明组合值大于b，进行剪枝
            break;
        }
        currentList.add(a[i]);
        //递归 ：递归加入当前位置的值
        combine(a,b - a[i],i,currentList,resultList);
        //回溯 ：如果当前组合的值于目标值的差值小于当前位置的值，进行回溯并选取下一位置的值
        currentList.remove(currentList.size() - 1);
    }
}
```

