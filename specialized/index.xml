<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Specializeds on 笔记网站</title><link>https://borongcheng.github.io/static/specialized/</link><description>Recent content in Specializeds on 笔记网站</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>私有财产</copyright><lastBuildDate>Thu, 11 Sep 2025 14:00:54 +0000</lastBuildDate><atom:link href="https://borongcheng.github.io/static/specialized/index.xml" rel="self" type="application/rss+xml"/><item><title>递归</title><link>https://borongcheng.github.io/static/specialized/algorithm/06%E9%80%92%E5%BD%92/</link><pubDate>Thu, 11 Sep 2025 14:00:54 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/algorithm/06%E9%80%92%E5%BD%92/</guid><description>一、定义 递归是一种通过调用自身来解决问题的编程技巧或算法。 在递归的过程中将问题分解为规模较小的子问题，并通过调用自身来解决这些子问题，最终将</description></item><item><title>动态规划</title><link>https://borongcheng.github.io/static/specialized/algorithm/07%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link><pubDate>Thu, 11 Sep 2025 14:00:54 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/algorithm/07%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid><description>一、定义 1、什么是动态规划？ 动态规划（Dynamic programing，简称DP），是一种在数学、管理学科、计算机科学，经济学和生物信息学</description></item><item><title>二叉树</title><link>https://borongcheng.github.io/static/specialized/algorithm/17%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Thu, 11 Sep 2025 14:00:54 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/algorithm/17%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>一、定义 二叉树搜索问题 深度优先遍历 DFS（Depth First Search） 是一种用于图和树的遍历算法，其核心思想是尽可能的搜索每一个分支，到达最深</description></item><item><title>贪心算法</title><link>https://borongcheng.github.io/static/specialized/algorithm/08%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</link><pubDate>Thu, 11 Sep 2025 14:00:54 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/algorithm/08%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</guid><description>一、定义 什么是贪心算法？ 贪心算法(greedy algorithm)，又称贪婪算法，是一种在每一步选择中都采取当前状态下最好或最优的选择，从而</description></item><item><title>最小生成树</title><link>https://borongcheng.github.io/static/specialized/algorithm/21%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link><pubDate>Thu, 11 Sep 2025 14:00:54 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/algorithm/21%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid><description>一、定义 最小生成树（Minimum Spancning Tree），是指在一个连接加权无向图中找到一个树（即无环连通子图），使得这个树包含所有顶点，且所有边的加</description></item><item><title>排序算法</title><link>https://borongcheng.github.io/static/specialized/algorithm/04%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link><pubDate>Tue, 09 Sep 2025 16:30:54 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/algorithm/04%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid><description>一、定义 选择排序 冒泡排序 插入排序 归并排序 是一种基于分治思想的排序，它将待排序数组分成若干个子数组，然后递归的对这些子数组进行排序，最后将子数</description></item><item><title>对数器</title><link>https://borongcheng.github.io/static/specialized/algorithm/02%E5%AF%B9%E6%95%B0%E5%99%A8/</link><pubDate>Mon, 08 Sep 2025 16:00:54 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/algorithm/02%E5%AF%B9%E6%95%B0%E5%99%A8/</guid><description>一、定义 随机行为 对数器原理</description></item><item><title>位运算</title><link>https://borongcheng.github.io/static/specialized/algorithm/01%E4%BD%8D%E8%BF%90%E7%AE%97/</link><pubDate>Sun, 07 Sep 2025 16:52:54 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/algorithm/01%E4%BD%8D%E8%BF%90%E7%AE%97/</guid><description>一、定义 二进制及其基本位运算 打印一个数的二进制形式 不用中间变量交换两个数 找到出现次数奇数次数的数 找到出现K次的数 N皇后问题的加速实现 位图 位运</description></item><item><title>ForkJoinPool</title><link>https://borongcheng.github.io/static/specialized/java/base/sourcereading/forkjoinpool/</link><pubDate>Fri, 25 Jul 2025 09:52:00 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/java/base/sourcereading/forkjoinpool/</guid><description>一、定义 forkjoinpool是java 7 开始提供的用于并行执行的任务框架，广泛用于java 8 的parallelStream和Comple</description></item><item><title>线程池</title><link>https://borongcheng.github.io/static/specialized/java/base/sourcereading/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link><pubDate>Fri, 25 Jul 2025 09:52:00 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/java/base/sourcereading/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid><description>https://www.cnblogs.com/star95/p/17714057.html 一、定义 1、什么是线程池？ 是一种管理和复用线程的机制，它通过预先创建一定数量的线程，将任务分配给这些线程执行，避免频繁的创建和销毁。 线程的</description></item><item><title>ConCurrentHashMap</title><link>https://borongcheng.github.io/static/specialized/java/base/sourcereading/concurrenthashmap/</link><pubDate>Sat, 28 Jun 2025 11:52:00 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/java/base/sourcereading/concurrenthashmap/</guid><description>一、定义 二、源码解读 入口 结构 get 根据hash值计算下标，拿到下标位置首节点。 根据首节点hash值判断是否为树节点，是则通过红黑树查找返回。 不是</description></item><item><title>HashMap</title><link>https://borongcheng.github.io/static/specialized/java/base/sourcereading/hashmap/</link><pubDate>Fri, 20 Jun 2025 15:30:00 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/java/base/sourcereading/hashmap/</guid><description>一、定义 二、源码阅读 入口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package java.lang; import java.util.HashMap; import java.util.Hashtable; import java.util.concurrent.ConcurrentHashMap; public class Map { static HashMap&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); public static void main(String[] args) { map.put(&amp;#34;1&amp;#34;, &amp;#34;1&amp;#34;); map.get(&amp;#34;1&amp;#34;); map.remove(&amp;#34;1&amp;#34;); } } Map结构 1 2 3 4</description></item><item><title>AOP切面</title><link>https://borongcheng.github.io/static/specialized/java/base/spring/aop/</link><pubDate>Wed, 28 Aug 2024 11:52:54 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/java/base/spring/aop/</guid><description>一、切面 https://www.cnblogs.com/lifullmoon/p/14654795.html 1、什么是AOP？ AspectJ：Aspect-oriented programming is a way of modularizing crosscutting concerns much like object-oriented programming is a way of modularizing common concerns. Spring：Aspect-</description></item><item><title>IOC容器</title><link>https://borongcheng.github.io/static/specialized/java/base/spring/core-container/</link><pubDate>Wed, 28 Aug 2024 11:52:54 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/java/base/spring/core-container/</guid><description>一、container 容器 （1）、容器简介 1、什么是容器？ 顾名思义，容器时存放物体的，在spring中容器是存放元数据的，也就是bean的实</description></item><item><title>Spring MVC</title><link>https://borongcheng.github.io/static/specialized/java/base/spring/spring-mvc/</link><pubDate>Wed, 28 Aug 2024 11:52:54 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/java/base/spring/spring-mvc/</guid><description>一、定义 1、什么是spring mvc？ spring mvc是一种web层的mvc框架，用于替代servlet（处理 || 响应请求）； spring mvc是spring体</description></item><item><title>事务</title><link>https://borongcheng.github.io/static/specialized/java/base/spring/transaction/</link><pubDate>Wed, 28 Aug 2024 11:52:54 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/java/base/spring/transaction/</guid><description>一、定义 1、什么是事务 事务就是一个并发控制单元，要求一次操作序列，要么全部成功要么全部失败。 这些操作要么全部成功，对数据造成影响，要么全部失</description></item><item><title>collection</title><link>https://borongcheng.github.io/static/specialized/java/collection/collection/</link><pubDate>Thu, 07 Dec 2023 16:52:54 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/java/collection/collection/</guid><description>collection map是根据key的hashcode函数计算出存入的位置 (h=key.hashcode())^(h&amp;raquo;&amp;gt;16); 1、先是调用key的hashcode函数，计算出对应的32位hash值， 2、再用</description></item><item><title>java基础</title><link>https://borongcheng.github.io/static/specialized/java/base/%E7%89%9B%E5%AE%A2%E7%BD%91java%E5%9F%BA%E7%A1%80/</link><pubDate>Thu, 07 Dec 2023 16:52:54 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/java/base/%E7%89%9B%E5%AE%A2%E7%BD%91java%E5%9F%BA%E7%A1%80/</guid><description>java基础 JDBC 1、执行对象Statement、PreparedStatement、CallableStatement 三者都是接口 Statem</description></item><item><title>JVM的对象布局--定义</title><link>https://borongcheng.github.io/static/specialized/java/jvm/jvm%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80/</link><pubDate>Thu, 07 Dec 2023 16:52:54 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/java/jvm/jvm%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80/</guid><description>JVM的对象布局&amp;ndash;定义 JVM的设计需要遵循JAVA虚拟机规范，所以在不同的虚拟机上，对象的布局结构基本相同，大小不一定相同。 一、</description></item><item><title>MySQL</title><link>https://borongcheng.github.io/static/specialized/database/relational/mysql/</link><pubDate>Thu, 07 Dec 2023 16:52:54 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/database/relational/mysql/</guid><description>MySQL 术语： 数据库: 数据库是一些关联表的集合。 数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。 列: 一列(数据元素) 包含了相</description></item><item><title>Redis系统学习</title><link>https://borongcheng.github.io/static/specialized/database/cache/redis%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</link><pubDate>Thu, 07 Dec 2023 16:52:54 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/database/cache/redis%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</guid><description>Redis 一、NoSQL的四大分类 K-V键值对： 新浪：Redis 美团：Redis + Tair 阿里、百度：Redis + memecache 文档数据库： MongoDB（必须掌握）</description></item><item><title>内部类</title><link>https://borongcheng.github.io/static/specialized/java/base/%E5%86%85%E9%83%A8%E7%B1%BB/</link><pubDate>Thu, 07 Dec 2023 16:52:54 +0000</pubDate><guid>https://borongcheng.github.io/static/specialized/java/base/%E5%86%85%E9%83%A8%E7%B1%BB/</guid><description>内部类 内部类：顾名思义，类内部的类； 一、为什么使用内部类 使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围</description></item></channel></rss>