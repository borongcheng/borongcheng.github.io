+++
date = "2025-09-11T14:00:54"
title = "贪心算法"
tags = ["算法"]
+++
# 一、定义
**什么是贪心算法？**

贪心算法(greedy algorithm)，又称贪婪算法，是一种在每一步选择中都采取当前状态下最好或最优的选择，从而希望导致结果是最好或最优的算法。

>  	只需要关注局部的特征，满足所有局部特征及和得到全局最优解。
>

是一种在每一步选择都是当前状态最优的情况下，希望能达到全局最优的算法策略。

它通常解决那些具有最优子结构的算法策略，即全局最优能通过局部最优去获取。



**贪心算法思路：**

+ 制定问题模型：
    - 将问题抽象成一个数学模型，明确数据的输入输出，以及约束。
+ 找到最优子结构:
    - 通过分析问题去获取最优子结构，即问题的最优解包含的子问题的最优解。
+ 制定贪心策略：
    - 根据最优子结构制定贪心策略，即每一步都是当前的最优选择，以期望全局最优。
+ 实现贪心算法：
    - 将贪心策略转化成具体的算法实现，一般都是通过迭代或者递归去完成。

> 贪心算法没有固定的套路，需要根据题目去手动模拟，通过数学归纳法或者反正法去证明可以通过贪心实现
>

**贪心算法会有哪些常见的题型？**

+ 字典序最小的字符串连接方案
+ 点灯问题
+ 分金条问题
+ 会议的最多安排
+ IPO问题
+ 求图中的最小生成树
+ 哈夫曼编码



# 二、实例
### 1、分糖果
[https://leetcode.cn/problems/candy/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/candy/description/?envType=study-plan-v2&envId=top-interview-150)

![](https://cdn.nlark.com/yuque/0/2024/png/22648511/1709793214653-ea300121-6485-402e-bff8-50bb1f99c384.png)

> 问题模型：
>
> 1、输入一个评分数组。
>
> 2、输出最少糖果数目。
>
> 3、约束最少分配一个糖，且相邻评分高的获得多。
>
> 最优子结构:
>
> 1、保证当前评分大于相邻评分时，获得的糖至少比前一位或后一位多一个。
>
> 2、保证评分为0时，最少获得一颗糖
>
> 贪心策略：
>
> 1、初始化一个数组，分配每个位为1，满足最优子结构1条件
>
> 2、从左往右遍历，保证当前位大于前一位评分时，当前位得糖数是前一位 + 1
>
> 3、从右往左遍历，保证当前位评分大于后一位评分，且当前位糖数小于后一位时，当前位得糖数为后一位 + 1
>

```java
public int candy(int[] ratings) {
        int count = 0;
        int[] nums = new int[ratings.length];
        // nums 初始每个位都为1
        // 从左往右 当前位置分数大于前一位分数，则当前位置加1
        for (int i = 0; i < nums.length; i++) {
            if (i > 0 && ratings[i] > ratings[i - 1]) {
                nums[i] = nums[i - 1] + 1;
            } else {
                nums[i] = 1;
            }
        }
        // 从右往左，当前位置大于后一位的分数，则当前位置加1
        for (int i = nums.length - 1; i >= 0; i--) {
            if (i < nums.length - 1 && ratings[i] > ratings[i + 1] && nums[i] <= nums[i + 1]) {
                nums[i] = nums[i + 1] + 1;
            }
            count = count + nums[i];
        }
        return count;
    }
```

### 2、卖股票的最佳时机
[https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&envId=top-interview-150)

[买卖股票的最佳时机-动态规划](https://www.yuque.com/tuoyueerwu/ey40ze/xnhesle1tbuo58po#s2Ct5)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给你一个整数数组</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">prices</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，其中 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">prices[i]</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">表示某支股票第</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">i</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">天的价格。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">在每一天，你可以决定是否购买和/或出售股票。你在任何时候 </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">最多</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 只能持有</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">一股</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">股票。你也可以先购买，然后在</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">同一天</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">出售。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">返回 </font>_<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">你能获得的 </font>__**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">最大</font>**__<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 利润</font>_<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">例：</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">prices = [7,1,5,3,6,4]</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">7</font>
>

**思路：**

+ 制定问题模型
    - 输入每天的股票价格
    - 输出买卖之后的最大利润
    - 限制条件：每天最多持有一支股票，可以进行买入或卖出
+ 最优子结构
    - 每次买入卖出的利润大于0，则最终的结果肯定是最大利润
+ 贪心策略
    - 选取第i天的股票，计算profitMax += max(0,prices[i] - prices[i -1]) 

```java
public static int maxProfit(int[] prices) {
        //贪心策略
        int profit = 0;
        for (int i = 1; i < prices.length; i++) {
            //最优子结构
            profit += Math.max(0,prices[i] - prices[i -1]);
        }
        return profit;
    }
```

### 3、跳跃游戏
[https://leetcode.cn/problems/jump-game/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/jump-game/description/?envType=study-plan-v2&envId=top-interview-150)

[跳跃游戏-动态规划](https://www.yuque.com/tuoyueerwu/ey40ze/xnhesle1tbuo58po#yI2u9)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给你一个非负整数数组 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">nums</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，你最初位于数组的</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">第一个下标</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">。数组中的每个元素代表你在该位置可以跳跃的最大长度。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">判断你是否能够到达最后一个下标，如果可以，返回 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">true</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> ；否则，返回 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">false</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">nums = [2,3,1,1,4]		nums = [3,2,1,0,4]</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">true					false</font>
>

**思路**

+ 制订问题模型
    - 输入每一个下标能跳跃的步数
    - 输出最后一个下标是否能够到达
+ 最优子结构
    - 每一步都跳跃最大的距离
+ 贪心策略
    - 维护每一次跳跃能够到达的最远位置
    - maxStep = Math.max(maxStep,nums[i] + i if i < maxStep)

```java
public boolean canJump(int[] nums) {
        // 贪心策略
        // 尽可能到所能到的最远位置 维护一个最远位下标
        int maxStep = 0;
        for (int i = 0; i < nums.length; i++) {
            if (i <= maxStep) {
                maxStep = Math.max(maxStep, nums[i] + i);
            }
        }
        return maxStep >= nums.length - 1;
    }
```

### 4、跳跃游戏2
> 与爬楼梯类似
>

[https://leetcode.cn/problems/jump-game-ii/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/jump-game-ii/description/?envType=study-plan-v2&envId=top-interview-150)

[跳跃游戏2-动态规划](https://www.yuque.com/tuoyueerwu/ey40ze/xnhesle1tbuo58po#iHdB9)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给定一个长度为</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">n</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">的</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">0 索引</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">整数数组</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">nums</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">。初始位置为</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">nums[0]</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">每个元素</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">nums[i]</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">表示从索引</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">i</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">向前跳转的最大长度。换句话说，如果你在</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">nums[i]</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">处，你可以跳转到任意</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">nums[i + j]</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">处:</font>
>
> + <font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">0 <= j <= nums[i]</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>
> + <font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">i + j < n</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">返回到达 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">nums[n - 1]</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 的最小跳跃次数。生成的测试用例可以到达 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">nums[n - 1]</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">。</font>
>

**思路**

+ 制定问题模型
    - 输入数组，下标对应可以跳跃的步数
    - 输出，跳到最后一个下标需要最少的步数
+ 最优子结构
    - 每一步都能跳最远的距离
+ 贪心策略
    - 倒序，查找上一步的位置，上一步的下标越小则跳的越远

```java
public int jump(int[] nums) {
    //贪心算法
    //最优子结构是，每次跳的最远，跳的次数就最少
    //倒序遍历，从最后一个节点找能跳到这个节点的下标，选择下标最小的一位
    int minCount = 0;
    int index = nums.length - 1;
    while (index > 0){
        int minIndex = nums.length;
        for (int i = index; i >= 0; i--){
            if (nums[i] + i >= index){
                minIndex = i;
            }
        }
        if (minIndex < index){
            index = minIndex;
            minCount++;
        }
    }
    return minCount;
}
```

### 5、左右文本对齐
[https://leetcode.cn/problems/text-justification/description/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/text-justification/description/?envType=study-plan-v2&envId=top-interview-150)

> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给定一个单词数组 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">words</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">和一个长度 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">maxWidth</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> ，重新排版单词，使其成为每行恰好有 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">maxWidth</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 个字符，且左右两端对齐的文本。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">你应该使用 “</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">贪心算法</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">' '</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 填充，使得每行恰好有</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>_<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">maxWidth</font>_<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 个字符。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">文本的最后一行应为左对齐，且单词之间不插入</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">额外的</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">空格。</font>
>

