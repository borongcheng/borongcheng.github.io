+++
date = "2025-09-11T14:00:54"
title = "二叉树"
tags = ["算法"]
+++
# 一、定义
+ 二叉树搜索问题
    - 深度优先遍历 DFS（Depth First Search）
        * 是一种用于图和树的遍历算法，其核心思想是尽可能的搜索每一个分支，到达最深的分支之后开始回溯前一个节点，继续搜索其他分支。
        * 递归实现
            + 在递归实现中，首先访问起始节点，并标记已访问。
            + 然后对当前节点调用递归函数，去访问其相邻的节点，访问到尾节点进行返回。
        * 栈实现
            + 维护一个数据结构栈，通过栈去存储待访问的节点。
            + 访问当前节点，标记访问，将其左右节点存入栈中
            + 弹出栈里节点，标记访问，再次将其左右节点存入栈中。
        * 使用场景
            + 连通性问题、拓扑排序问题、寻找路径问题
            + 前序、中序、后序遍历
        * 时间复杂度
            + O(V+E) V顶点数、E边数
+ 先序、中序、后序的递归遍历
+ 先序、中序、后序的非递归遍历
+ 相同树问题
+ 相似树问题
+ 二叉树最大深度问题
+ 根据先序和中序重建二叉树
+ 二叉树路径问题
+ 二叉树按层遍历
+ 二叉树的序列化和反序列化
+ 后继、前驱节点
+ 判断完全二叉树
+ 判断搜索二叉树
+ 判断平衡二叉树
+ 二叉搜索树（<font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">Binary Search Tree</font>）
    - 每个节点都最多包含两个子树
    - 其中左子树的值小于当前节点，右子树的值大于当前节点
    - BST中不存在重复的节点



# 二、实例
## 先、中、后序遍历
> 先序遍历
>
> 先输出根节点,再遍历左子树，后遍历右子树
>

```java
     1
    / \
   2   3
  / \ / \
 4  5 6  7
输出：1 2 3 4 5 6 7
public static void topTraversal(TreeNode node){
    if (node != null){
        System.out.print(node.val + " ");
        topTraversal(node.left);
        topTraversal(node.right);
    }
}
```

> 中序遍历
>
> 先遍历左子树，再输出根节点，最后输出右节点
>
> 找到最左，然后按左-中-右顺序输出
>

```java
     1
    / \
   2   3
  / \ / \
 4  5 6  7
输出: 4 2 5 1 3 6 7
public static void inorderTraversal(TreeNode node){
    if (node != null){
        //获取到最左的左子树，开始打印
        inorderTraversal(node.left);
        System.out.println(node.val + "");
        inorderTraversal(node.right);
    }
}
```



> 后序遍历
>
> 先遍历左子树，再遍历右子树，最后打印根节点
>
> 找到最左，然后以左-右-中的形式打印节点
>

```java
     1
    / \
   2   3
  / \ / \
 4  5 6  7
输出: 4 5 2 6 7 3 1
public static void inorderTraversal(TreeNode node){
    if (node != null){
        //获取到最左的左子树，开始打印
        inorderTraversal(node.left);
        inorderTraversal(node.right);
        System.out.println(node.val + "");
    }
}
```

## DFS
> 二叉树-DFS 深度优先遍历
>
> 判断两个二叉树是否结构相同
>

```java
public static boolean depthSearch(TreeNode p, TreeNode q) {
        //判断当前节点是否是尾节点
        if (p == null && q == null){
            return true;
        }
        //判断当前节点是否需要返回
        if ((p == null || q == null) || (p.val != q.val)){
            return false;
        }
        //递归调用，尾节点回溯
        return depthSearch(p.left,q.left) && depthSearch(p.right,q.right);
    }
```

```java

```



## BFS
> 二叉树-BFS 广度优先遍历
>
> 判断两个二叉树是否结构相同
>

```java
public static boolean breathFirstSearch(TreeNode p, TreeNode q){
        //广度优先搜索 BFS 从起始节点开始逐层的扩展向外，先访问起始节点最近的节点，然后逐渐再扩展到离起始节点最远的节点
        //判断当前节点
        if (p == null && q == null){
            return true;
        }
        if ((p == null || q == null) || (p.val != q.val)){
            return false;
        }
        //构造队列
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(p);
        queue.offer(q);
        while (!queue.isEmpty()){
            //一次取两个节点 因为队列插入的逻辑，必定是取到两个node对应的不同节点
            TreeNode node1 = queue.poll();
            TreeNode node2 = queue.poll();
            if (node1.val != node2.val){
                return false;
            }
            //左节点插入
            if (node1.left != null && node2.left != null){
                queue.offer(node1.left);
                queue.offer(node2.left);
            }else if (node1.left != null || node2.left != null){
                return false;
            }
            //右节点插入
            if (node1.right != null && node2.right != null){
                queue.offer(node1.right);
                queue.offer(node2.right);
            }else if (node1.right != null || node2.right != null){
                return false;
            }
        }
        return true;
    }
```

