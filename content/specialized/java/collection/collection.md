# collection

![image-20201019091357553](D:\笔记图片\image-20201019091357553.png)

**map是根据key的hashcode函数计算出存入的位置**

(h=key.hashcode())^(h>>>16);   

1、先是调用key的hashcode函数，计算出对应的32位hash值，

2、再用这个hash值与它自己向右移16位的数字进行异或运算得到一个整数 （hashvalue）

3、将这个整数进行运算得出该hash值在数组中的位置， hash=（hashvalue%n），hash=（hash&（n-1）），n表示map的默认长度。

4、通过计算出来的0-15的数值去大小为16的数组中查找对应的节点

5、再根据节点是否存在值进行替换或者插入

6、存在时，调用key的hashcode方法计算出hash值，与存在这里的key的hash比较，相同则替换，不同则在这个节点后面链接一个节点

​		链接的原则是一致next，然后比较key的hash是否相同，直到一个next为null才写入。

7、不存在则直接写入。





**问题**：

1、为什么扩容时有的是链表有的是红黑树呢？

刚开始的时候，一定是链表，因为单向链表的时间复杂度是O(n)；当n的数量增加，O(n)的时间复杂度就越高。

当链表的长度大于8的时候，就可以用红黑树代替链表，O(lodg n)==>n越大时，时间复杂度越小。

2、为什么map里面的数组大小要是2^n呢？

大概了解了一下，和用异或运算之后的值取模或者与运算有关，如果不是2^n,会有node节点的index相同，这样就需要通过链表和红黑树解决，要是不同则可以直接通过数组层面解决，时间复杂度低。



**HashMap的线程安全问题**

**问题：**

1、hashmap解决线程问题？

**加synchronized，hashTable实现；**

hashTable就是在方法外加synchronized；

但是hashTable的粒度太重，将操作强制串行化，所以效率有点地下、



ConcurentHashMap实现；

缩小锁的范围，并且逐步判断每一步是否有安全问题，逐个解决。

和hashtable的区别：

​		先是用cas算法锁定每个数组槽点的标记，有线程进行操作时，修改标记为-1，其他线程无法进入，然后在单个槽点的后续操作与hashtable相同，加synchronized；

​		**主要执行两次CAS算法：先是数组初始化，再是检索索引的下标时使用**

​		而hashtable的话是直接用synchronized锁定整个对象，执行串行化的操作。



2、怎么保证数组扩容时线程是安全的呢？

有线程调用扩容方法时，会将对应头节点的hash值变成-1；

其他线程识别到对应的头节点hash值为-1会停止插入数据操作；

其他线程在等待的过程中会协助扩容的线程进行扩容。





线程每次执行扩容时，每次领取16个位置的扩容，单个线程需要领取四次；倒着创建n-（n-16）======>15-0





**对ConcurentHashMap的理解**

为什么如此重要？

* 存储结构，数据结构和算法
* 并发编程：ssynchronized和cas算法
* 各种复杂的计算；

