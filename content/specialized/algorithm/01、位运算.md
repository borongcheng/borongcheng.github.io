+++
date = "2025-09-07T16:52:54"
title = "位运算"
tags = ["算法"]
+++
# 一、定义
+ 二进制及其基本位运算
+ 打印一个数的二进制形式
+ 不用中间变量交换两个数
+ 找到出现次数奇数次数的数
+ 找到出现K次的数
+ N皇后问题的加速实现
+ 位图
+ 位运算实现加、减、乘、除



<font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">位运算是对整数在内存中二进制表示的位进行操作的一种运算。常见的位运算包括与（&）、或（|）、异或（^）、取反（~）、左移（<<）和右移（>>）等。</font>

1. <font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">与运算（&）：对两个数的每一位执行与操作，只有当两个数对应位都为1时结果为1，否则为0。</font><font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">例如：1010 & 1100 = 1000</font>
2. <font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">或运算（|）：对两个数的每一位执行或操作，只要两个数对应位有一个为1，结果就为1。</font><font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">例如：1010 | 1100 = 1110</font>
3. <font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">异或运算（^）：对两个数的每一位执行异或操作，如果两个数对应位相同则结果为0，不同则结果为1。例如：1010 ^ 1100 = 0110 ,任何数  ^ 0都为本身</font>
4. <font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">取反运算（~）：对一个数的每一位执行取反操作，即将0变为1，1变为0。</font><font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">例如：~1010 = 0101</font>
5. <font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">左移运算（<<）：将一个数的所有位向左移动指定的位数，右侧空出的位用0填充。</font><font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">例如：1010 << 2 = 101000</font>
6. <font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">右移运算（>>）：将一个数的所有位向右移动指定的位数，左侧空出的位根据符号位填充（对于有符号数，用符号位填充；对于无符号数，用0填充）。</font><font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">例如：1010 >> 1 = 0101</font>

<font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">这些位运算操作通常用于优化代码、处理底层数据结构以及密码学等领域。在实际编程中，位运算可以提高程序的执行效率和降低内存消耗。</font>

# 二、示例
> 给定一组数字，其中一个数字出现奇次，其他数字出现偶次，输出出现奇次的数。
>

```java
public int test(int[] nums){
    int temp = 0;
    for(int num : nums){
        temp = temp ^ num;
    }
    return temp;
}
```

> 给定一组数字，其中两个数字出现奇次，其他数字出现偶次，输出出现奇次的数。
>

```java
//1、第一遍循环，获得 eor = A ^ B
//2、A!=B 所以 temp != 0  那么eor所表示的二进制位肯定有一位是1
//3、提取出eor其中的一个1 将数组中的数分成该位置为1的和该位置为0的数
//4、第二次循环，将该位置为1的数异或，肯定会获得A或B中的一个
public int[] test(int[] nums){
    int eor = 0;
    for(int num : nums){
        eor = eor ^ num;
    }
    //取eor最右侧的1
    //eor     = 1010111100
    //~eor    = 0101000011
    //~eor+ 1 = 0101000100
    //eor &(~eor + 1) = 000000100
    int rightOne = eor &(~eor + 1);

    int onlyOne = 0;
    for(int cur : arr){
        // 对应位相同，& 会为0
        if((cur & rightOne) == 0){
            onlyOne ^= cur;
        }
    }
    return new int[]{eor ^ onlyOne,onlyOne};
}
```

